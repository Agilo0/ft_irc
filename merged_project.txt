/* ========================================= */
/*      MERGED IRC SERVER SOURCE FILE        */
/* ========================================= */


/* ===== FILE: inc/Channel.hpp ===== */

#ifndef CHANNEL_HPP
#define CHANNEL_HPP

//#include "Server.hpp"
//#include "Utils.hpp"

enum CommandType{
	PASS,
	NICK,
	USER,
	PART,
	//CAPEND,
	JOIN,
	WHO,
	PRIVMSG,
	KICK,
	INVITE,
	TOPIC,
	MODE,
	QUIT,
	PING,
	UKNW
};


class Channel{
	private:
		std::string	_name;
		std::string _topic;
		std::string _key;//optional key to join the channel
		size_t		_maxUsers;
		bool		_iMode;//(-/= invite only)
		bool		_tMode;//(topic set by operators only)
		bool		_kMode;
		bool		_oMode;
		bool		_lMode;
		std::set<int> _clients;//all the clients that we have in the channel (store FDs)
		std::set<int> _operators;//operator is the one that has more privileges in the channel
		std::set<int> _invited;//clients that are invited to the channel
	
	public:
		Channel(const std::string &name);
		
		/*getters*/
		std::string getName() const;//get channel name
		std::string getTopic() const;
		std::string getKey() const;
		size_t		getMaxUsers() const;
		const std::set<int> &getClients() const;
		
		/*setters*/
		void setTopic(const std::string &topic);
		void setKey(const std::string &key);
		void setMaxUsers(int max);
		
		void setModeI(bool active);
		void setModeT(bool active);
		void setModeK(bool active);
		void setModeO(bool active);
		void setModeL(bool active);
		
		/*booleans*/
		bool hasTopic() const;
		bool isModeI() const;
		bool isModeT() const;
		bool isModeK() const;
		bool isModeO() const;
		bool isModeL() const;
		//bool hasKey() const;

		bool isEmpty() const;

		bool addClient(int fd, bool isOperator = false);
		bool isMember(int fd) const;
		bool isOperator(int fd) const;
		bool isInvited(int fd) const;

		//client management
		void removeClient(int fd);
		void addOperator(int fd);
		void removeOperator(int fd);
		void inviteClient(int fd);
		void removeInvite(int fd);

		//modes
		int manageModeChange(std::string mode, std::string arg, int targetFd);
		void manageK(bool sign, std::string arg);
		int manageO(bool sign, int targetFd);
		int manageL(bool sign, std::string arg);
		bool isStrictNumber(const std::string &s);
};


#endif
/* ===== FILE: inc/Client.hpp ===== */

#ifndef CLIENT_HPP
#define CLIENT_HPP

#include <string>
// #include "Server.hpp"
#include "Channel.hpp"

enum Status
{
    NOT_AUTHENTICATED,
    AUTHENTICATED
};

class Client
{
private:
    int _clientFd;
    std::string _nickname;
    std::string _oldnick;
    std::string _username;
    std::string _realname;
    std::string _ip; // or host
    std::string _buffer;
    Status _status;
    bool hasNick, hasUser, hasPass;
    bool _toRemove;
    std::vector<std::string> _channels;

public:
    Client();
    ~Client();

    // getters
    Status getStatus();
    int getClientFd() const; //<--socket FD of the client
    std::string getUsername() const;
    std::string getNickname() const;
    std::string getClientIP() const;
    std::string &getBuff();
    std::string getNick() const;
    std::string getOldnick() const;
    //Channel *getChannel(unsigned int index);
    std::string getRealname() const;

    // setters
    void setStatus(Status status);
    void setClientFd(int fd);
    void setClientIP(const std::string &newIP);
    void setPass();
    void setFirstNick(std::string nick);
    void setNewNick(std::string nick);
    void setRealName(std::string name);
    void setUser(std::string name);
    void setChannel(Channel *channel);

    // bools
    bool hasAll() const;
    bool hasPassw() const;
    bool hasNickname() const;
    bool hasUsername() const;
    bool isToRemove() const;
    bool isRegistered() const;

    // others
    void markForRevome();
    void addBuffer(const std::string &data);
    //int quitChannel(std::string channel);
    std::string createMessage();
    std::vector<std::string> getChannelVect();
};

#endif

/* ===== FILE: inc/Responses.hpp ===== */

#ifndef RESPONSE_HPP
# define RESPONSE_HPP

// JOIN
#define ERR_NOSUCHCHANNEL(channel) (std::string("403 ") + channel + " :No such channel")
#define ERR_CHANNELISFULL(nickname, channel) (std::string(":server_name 471 " + nickname + " " + channel + " :Cannot join channel (+l)"))
#define ERR_INVITEONLYCHAN(channel) (std::string("473 " + channel + " :Cannot join channel (+i)"))
#define ERR_BADCHANNELKEY(nickname, channel) (std::string("475 " + nickname + " " + channel + " :Cannot join channel (+k)"))
#define RPL_JOIN(nickname, username, hostname, channel) \
    (std::string(":" + nickname + "!" + username + "@" + hostname + " JOIN :" + channel))
#define RPL_NAMREPLY(servername, nickname, channel, clientlist) \
    (std::string(":" + servername + " 353 " + nickname + " = " + channel + " :" + clientlist))
#define RPL_ENDOFNAMES(serverName, nickname, channel) (std::string(":" + serverName + " 366 " + nickname + " " + channel + " :End of /NAMES list"))


//user
#define ERR_NEEDMOREPARAMS(client, command) (std::string("461 ") + (client) + " " +(command) + " :Not enough parameters")
//PRIVMSG
#define ERR_NORECIPIENT(servername) (std::string(":" + servername + " 411 :No recipient given (PRIVMSG)"))
#define ERR_NOTEXTTOSEND(servername) (std::string(":" + servername + " 412 :No text to send"))
#define ERR_CANNOTSENDTOCHAN(servername, channel) (std::string(":" + servername + " 404 " + channel + " :Cannot send to channel"))
#define ERR_NOSUCHNICK(servername, nickname) (std::string(":" + servername + " 401 " + nickname + " :No such nick/channel"))
#define RPL_PRIVMSG(sender, receiver, message) (std::string(":" + sender + " PRIVMSG " + receiver + " " + message))



// WELCOME
#define RPL_WELCOME(nickname, servername, hostname) \
   (std::string(":" + servername + " 001 " + nickname + \
   " :Welcome to the " + servername + " Network, " + nickname + "! " + hostname))
#define RPL_YOURHOST(servername, nickname) \
    (std::string(":" + servername + " 002 " + nickname + " Your host is " + servername + ", running version 1.0"))
#define RPL_CREATED(servername, time) \
    (std::string(":" + servername + " 003 This server was created " + time))
#define RPL_MYINFO(servername, nickname) \
    (std::string(":" + servername + " 004 " + nickname + " " + servername))
#endif


//PASS
#define ERR_ALREADYREGISTERED(nick) ("462 :You may not reregister" )
#define ERR_PASSWDMISMATCH(nick) ("464 :Password incorrect" )


//NICK
#define ERR_NONICKNAMEGIVEN() (std::string("431 ") + " :No nickname given" )
#define ERR_ERRONEUSNICKNAME(nick) (std::string("432 ") + nick + " :Erroneous nickname" )
#define ERR_NICKNAMEINUSE(nick) (std::string("433 ") + nick + " :Nickname is already in use" )
#define NICK_UPDATE(oldnick, nick) (":" + oldnick + " NICK " + nick)

//USER
#define ERR_NOTREGISTERED(nick) ("451 " + nick + " :You have not registered")

//PART
// #define ERR_NOSUCHCHANNEL(nick, channel) ("403 " + nick + channel + " :No such channel")
#define ERR_NOTONCHANNEL(nick, channel) ("442 " + nick + channel + " :You're not on that channel")
#define RPL_PART(message, channel, reason) (message + " PART " + channel + " " + reason)

//KICK
#define ERR_CHANOPRIVSNEEDED(nick, channel) ("482 " + nick + " " + channel + " :You're not channel operator")
#define ERR_USERNOTINCHANNEL(nick, targetnick, channel) ("441 " + nick + " " + targetnick + " "  + channel + " :They aren't on that channel")
#define KICK(message, channel, targetNick, reason) (message + " KICK " + channel + targetNick + reason)

//MODE
#define ERR_UNKNOWNCOMMAND(servername, nick, command) (":" + servername + " 421 " + nick + command + " :Unknown command")
#define ERR_INVALIDMODEPARAM(servername, nick, channel, mode, argument) (":" + servername + " 696 " + nick + channel + mode + argument + " :Invalid mode parameter")

//INVITE
#define ERR_USERONCHANNEL(servername, nick, target, channel) (":" + servername + " 443 " + nick + " " + target + " " + channel + " :Is already on channel")
#define RPL_INVITING(servername, nick, target, channel) (":" + servername + " 341 " + nick + " " + target + " " + channel)
#define INVITE(message, nick, channel) (message + " INVITE " + nick + " " + channel)

//QUIT
#define QUIT(message, reason) (message + " QUIT :" + reason)

//TOPIC
#define RPL_TOPIC(nick, channel, topic) ("332 " + nick + " " + channel + " " + topic)
#define RPL_NOTOPIC(nick, channel) ("331 " + nick + " " + channel + " :No topic is set")
#define TOPIC(message, channel, topic) (message + " TOPIC " + channel + " :" + topic)

//WHO
#define RPL_WHOREPLY(nick, channel, message) ("352 " + nick + " " + channel + message)
#define RPL_ENDOFWHO(nick, mask) ("315 " + nick + " " + mask + " :End of WHO list")

/* ===== FILE: inc/Server.hpp ===== */

#ifndef SERVER_HPP
# define SERVER_HPP

#include "Utils.hpp"
#include "Client.hpp"
#include "Channel.hpp"
#include "Responses.hpp"

class Server{
    private:
		int _port;
		int _servFd;
		static bool _sigFlag;
		std::string _pwd;
		std::string _serverName;
		std::vector<struct pollfd> _pollFds;
		std::vector<Client> _clients;
		std::vector<Channel> _channels;


	//DETELE THEM
	void printChannels(const std::vector<Channel>& _channels);
	void printClients(std::vector<Client>& _clients);



	//utils.cpp
		bool checkNick(std::string nick);
		bool checkUser(std::string user) const;
		bool nickTaken(std::string nick) const;
		std::string appendToks( const std::vector<std::string> &tokens, int start);
		bool checkSyn(std::string channel);
		bool channelExist(std::string channel);
		void removeChannel(std::string chan);
		bool checkKick(std::vector<std::string> &tokens);
		bool emitorInChannel(int emitFd, std::string channel);
		bool emitorOperator(int fd, std::string channel);
		bool targetInChannel(std::string channel, int targetFd);
		int targetExist(std::string nick);
		void removeTarget(std::string channel, int targetFd);
		bool isChangeMode(std::string mode);
		bool validMode(std::string mode);
		int findTarget(std::string nick);
		void deleteClient(Client* cli);
		int whoType(std::string cmd);
		std::string buildWhoMessage(int fd, bool op);
		Channel* findChannel(std::string name);


	//ServerAuth.cpp
		void passAuth(Client *cli, const std::vector<std::string> &tokens);
		void nickAuth(Client *cli, const std::vector<std::string> &tokens);
		void userAuth(Client *cli, const std::vector<std::string> &tokens);
		void handShake(Client *cli, const std::string &command);
	
	//Server.cpp (COMMANDS)
		void parseCommand(Client *cli, const std::string &command);
		void handleJoin(Client *cli, const std::vector<std::string> &tokens);
		void handlePrivmsg(Client *cli, const std::vector<std::string> &tokens);
		void handlePart(Client *cli, const std::vector<std::string> &tokens);
		void handleKick(Client *cli, std::vector<std::string> &tokens);

		void handleMode(Client *cli, std::vector<std::string> &tokens);
		void handleInvite(Client *cli, std::vector<std::string> &tokens);
		void handleQuit(Client *cli, std::vector<std::string> &tokens);
		void handleTopic(Client *cli, std::vector<std::string> &tokens);
		void handleWho(Client *cli, std::vector<std::string> &tokens);
		void handlePing(Client *cli, std::vector<std::string> &tokens);
	
	//Client.cpp
		CommandType isCommand(const std::string &cmd);
		void sendResponse(int clientFd, const std::string &response);
	
	//ServerAux.cpp
		Channel* moveCreateChannel(const std::string &channelName);
		Client *getClient(int fd);
		Client *getClientByNick(const std::string &dest);

	//Notification.cpp
		void broadcastNewNick(Client *cli);//works with channels
		std::vector<int> notifChannel(Channel *chan, std::string old, std::string nick, std::vector<int> ok);
		void broadcastPart(std::string chann, std::string message, std::string reason);
		void broadcastKick(std::string chann, std::string message, std::string nick, std::string reason);
		void broadcastMode(Channel *chann, std::string message);
		void broadcastQuit(Client *cli, std::string message, std::string reason);
		std::vector<int> notifChannelQuit(Channel *chan, std::string message, std::string reason, std::vector<int> ok);
		void broadcastTopic(std::string message, Channel *channel, std::string topic);
		
	
	//ServerCommands.cpp
		
    public:
		Server();
	//server.cpp
		void createSocket();
		void initServer(int port, std::string pwd);
	//ServerAux.cpp
		static void sigHandler(int signum);
		void checkNewClient();
		void checkNewData(int fd);
		void clearClient(int fd);
		void close_fds(std::vector<pollfd> &pollFds);

	
};

#endif

/* ===== FILE: inc/Utils.hpp ===== */

#ifndef UTILS_HPP
# define UTILS_HPP

/*	/---------------\
   |	LIBRARIES 	 |
	\---------------/
*/
#include <iostream>
#include <string>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <csignal>
#include <sys/socket.h>
#include <netinet/in.h> //Internet address family
#include  <arpa/inet.h>
#include <fcntl.h>
#include <cerrno>
#include <unistd.h>
#include <poll.h>
#include <vector>
#include <iostream>
#include <set>
#include <sstream>
#include <algorithm>

/*	/---------------\
   |	COLORS	 	 |
	\---------------/
*/

#define NC "\033[0m"
#define RED "\e[1;91m"
#define GREEN "\e[1;92m"
#define YELLOW "\e[1;93m"
#define BLUE "\e[1;94m"
#define TURQUOISE "\e[1;38;5;80m"
#define FUCSIA "\e[1;38;5;201m"
#define PURPLE "\e[1;38;5;135m"
#define ORANGE "\e[1;38;2;255;128;0m"

//no utils class needed
class Utils{
	public:
		static std::vector<std::string>	split(const std::string &str, char delimiter);
        static int check_port(char *port);
		static bool check_password(const std::string &password);
         
};

//static std::vector<std::string>	split(const std::string &str, char delimiter);//is not defined yet 
//std::string convertResponse(const std::string &response);
#endif
/* ===== FILE: srcs/Channel.cpp ===== */

#include "Server.hpp"

Channel::Channel(const std::string &name) :
	_name(name),_topic(""),_key(""),
	_maxUsers(0), _iMode(false), _tMode(false),
	_kMode(false), _oMode(false), _lMode(false) {}

/*getters*/
std::string Channel::getName() const{ return _name; }
std::string Channel::getTopic() const{ return _topic; }
std::string Channel::getKey() const{ return _key; }
size_t Channel::getMaxUsers() const{ return _maxUsers; }
const std::set<int> &Channel::getClients() const{ return _clients; }

/*setters*/
void Channel::setTopic(const std::string &topic){ _topic = topic; }
void Channel::setKey(const std::string &key){
	_key = key;
	_kMode = true;
}
void Channel::setMaxUsers(int max){ _maxUsers = max; }

/*MODES*/
void Channel::setModeI(bool active){ _iMode = active;}
void Channel::setModeT(bool active){ _tMode = active;}
void Channel::setModeK(bool active){ _kMode = active;}
void Channel::setModeO(bool active){ _oMode = active;}
void Channel::setModeL(bool active){ _lMode = active;}

bool Channel::hasTopic() const {return !_topic.empty();}
bool Channel::isModeI() const {return _iMode; }//this has been previously changed by his set function
bool Channel::isModeT() const {return _tMode; }
bool Channel::isModeK() const {return _kMode; }
bool Channel::isModeO() const {return _oMode; }
bool Channel::isModeL() const {return _lMode; }

///						*WIP									*/
//NOT quite sure if we should use clean or create an specific function
// void Channel::removeClient(int fd){
// 	(void)fd;//but we should use the fd to know the exact client we are talking about
// 	_clients.clear();
// 	_operators.clear();
// }
void Channel::removeInvite(int fd){
	(void)fd;
	//remove the invitation
}
void Channel::removeOperator(int fd){
	(void)fd;
	//remove operator privileges
}


//we add the client to the operators list (if they are on the list)
void Channel::addOperator(int fd){
	if (_clients.count(fd))//it give us the match of the client
		_operators.insert(fd);
}
void Channel::inviteClient(int fd){ _invited.insert(fd); }

//new client has been add if we still have space left
bool Channel::addClient(int fd, bool isOperator){
	if (_lMode && _clients.size() >= _maxUsers)
		return false;
	_clients.insert(fd);
	if (isOperator)
		_operators.insert(fd);
	return true;
}
//if we found this fd on the list, means that is a member
bool Channel::isMember(int fd) const { return _clients.find(fd) != _clients.end(); }
bool Channel::isOperator(int fd) const { return _operators.find(fd) != _operators.end(); }

//bool Channel::isInvited(int fd) const { return _clients.find(fd) != _clients.end(); }
bool Channel::isInvited(int fd) const { return _invited.find(fd) != _invited.end(); }

void Channel::removeClient(int fd){
	_clients.erase(fd);
	_operators.erase(fd);
}

bool Channel::isEmpty() const {
	if (_clients.empty())
		return (true);
	return (false);
}

int Channel::manageModeChange(std::string mode, std::string arg, int targetFd){
	bool sign;
	if (mode[0] == '+')
		sign = true;
	else
		sign = false;
	if (mode[1] == 'i'){
		setModeI(sign);
		return(0);
	}
	else if (mode[1] == 't'){
		setModeT(sign);
		return(0);
	}
	if (arg == "")
		return(1);
	if (mode[1] == 'k'){
		manageK(sign, arg);
		return (0);
	}
	if (mode[1] == 'o'){
		if (manageO(sign, targetFd) == 1)
			return (2);
	}
	if (mode[1] == 'l'){
		if (manageL(sign, arg) == 1)
			return (3);
	}
	return (0);
}

void Channel::manageK(bool sign, std::string arg){
	setModeK(sign);
	if (sign == true)
		_key = arg;
	else
		_key.clear();
}

int Channel::manageO(bool sign, int targetFd){
	if (!isMember(targetFd))
		return (1);
	if (sign == true)
		addOperator(targetFd);
	else if (sign == false)
		removeOperator(targetFd);
	setModeO(sign);
	return (0);
}

int Channel::manageL(bool sign, std::string arg){
	if (sign == true){
		if (!isStrictNumber(arg))
        	return (1);
		size_t limit;
		std::stringstream ss(arg);
		ss >> limit;
		if (limit == 0)
			return (1);
		_maxUsers = limit;
		setModeL(true);
	}
	else
		setModeL(sign);
	return (0);
}

bool Channel::isStrictNumber(const std::string &s){
    size_t i = 0;
    if (s.empty())
        return false;
    while (i < s.size()){
        if (!std::isdigit(s[i]))
            return false;
        i++;
    }
    return true;
}

/* ===== FILE: srcs/Client.cpp ===== */

#include "Server.hpp"
//#include "Channel.hpp"

Client::Client(){
    hasNick = false;
	hasUser = false;
	hasPass = false;
	_status = NOT_AUTHENTICATED;
    _toRemove = false;
}

Client::~Client() {}

//setters
void Client::setStatus(Status status){ _status = status; }
void Client::setClientFd(int fd){ _clientFd = fd; }
void Client::setClientIP(const std::string &newIP) { _ip = newIP; }
void Client::setPass() { hasPass = true; }
void Client::setFirstNick(std::string nick){
	_nickname = nick;
	hasNick = true;
}
void Client::setNewNick(std::string nick){
	_oldnick = _nickname;
	_nickname = nick;
}
void Client::setUser(std::string name){
	_username = name;
	hasUser = true;
}
void Client::setRealName(std::string name) { _realname = name; }
void Client::setChannel(Channel *channel) { _channels.push_back(channel->getName()); }



//getters
Status Client::getStatus() { return _status; }
int Client::getClientFd() const { return _clientFd; }
std::string Client::getClientIP() const { return _ip; }
std::string Client::getUsername() const { return _username; }
std::string Client::getNickname() const { return _nickname;}
std::string &Client::getBuff() { return _buffer; }
std::string Client::getNick() const { return (_nickname); }
std::string Client::getOldnick() const{ return (_oldnick); }
// Channel *Client::getChannel(unsigned int index){
// 	if (_channels.size() > index)
// 		return (_channels[index]);
// 	return (NULL);
// }
std::string Client::getRealname() const{
	return (_realname);
}


//bools
bool Client::hasAll() const{
	if (hasPass == true && hasNick == true && hasUser == true)
		return (true);
	return (false);
}
bool Client::hasNickname() const { return (hasNick);}
bool Client::hasUsername() const { return (hasUser); }
bool Client::hasPassw() const { return (hasPass); }
bool Client::isToRemove() const { return (_toRemove); }
bool Client::isRegistered() const { return _status /* == AUTHENTICATED */; }



//others
void Client::markForRevome() { _toRemove = true; }
void Client::addBuffer(const std::string &data){ _buffer += data; }
std::string Client::createMessage(){
	std::string res;

	res.append(":");
	res.append(_nickname);
	res.append("!");
	res.append(_username);
	res.append("@");
	res.append(_ip);
	return (res);
}
std::vector<std::string> Client::getChannelVect(){
	return (_channels);
}


/* ===== FILE: srcs/Notification.cpp ===== */

#include "Server.hpp"

void Server::broadcastNewNick(Client *cli){
	std::vector<int> clientFdsOk;
	std::vector<int> res;
	std::vector<std::string> channels = cli->getChannelVect();
	std::vector<std::string>::iterator it = channels.begin();

	while (it != channels.end()){
		clientFdsOk = notifChannel(findChannel((*it)), cli->getOldnick(), cli->getNickname(), clientFdsOk);
		it++;
	}
}
std::vector<int> Server::notifChannel(Channel *chan, std::string old, std::string nick, std::vector<int> ok){
	std::set<int> clients = chan->getClients();
	std::set<int>::iterator it = clients.begin();
	
	while (it != clients.end()){
		int fd = *it;
		if (std::find(ok.begin(), ok.end(), fd) == ok.end()){
			sendResponse(fd, NICK_UPDATE(old, nick));
			ok.push_back(fd);
		}
		it++;

	}
	return (ok);
}

void Server::broadcastPart(std::string chann, std::string message, std::string reason){
	std::vector<Channel>::iterator it = _channels.begin();

	while (it != _channels.end()){
		if (chann == (*it).getName()){
			std::set<int> clients = (*it).getClients();
			std::set<int>::iterator itc = clients.begin();
			while (itc != clients.end()){
				int fd = *itc;
				sendResponse(fd, RPL_PART(message, (*it).getName(), reason));
				itc++;
			}
			return;
		}
		it++;
	}
}

void Server::broadcastKick(std::string chann, std::string message, std::string nick, std::string reason){
	std::vector<Channel>::iterator it = _channels.begin();

	while (it != _channels.end()){
		if (chann == (*it).getName()){
			std::set<int> clients = (*it).getClients();
			std::set<int>::iterator itc = clients.begin();
			while (itc != clients.end()){
				int fd = *itc;
				sendResponse(fd, KICK(message, chann, nick, reason));
				itc++;
			}
			return;
		}
		it++;
	}
	(void)nick;
}

void Server::broadcastMode(Channel *channel, const std::string message){
	std::set<int> clients = channel->getClients();
	std::set<int>::iterator itc = clients.begin();
	while (itc != clients.end()){
		int fd = *itc;
		sendResponse(fd, message);
		itc++;
	}
	return;
}

void Server::broadcastQuit(Client *cli, std::string message, std::string reason)
{
	std::vector<int> clientFdsOk;
    std::vector<Channel>::iterator it = _channels.begin();
    clientFdsOk.push_back(cli->getClientFd());

	while (it != _channels.end()){
        if ((*it).isMember(cli->getClientFd()))
            clientFdsOk = notifChannelQuit(&(*it), message, reason, clientFdsOk);
		it++;
	}
}

std::vector<int> Server::notifChannelQuit(Channel *chan, std::string message, std::string reason, std::vector<int> ok)
{
	std::set<int> clients = chan->getClients();
	std::set<int>::iterator it = clients.begin();
	
	while (it != clients.end())
	{
		int fd = *it;
		if (std::find(ok.begin(), ok.end(), fd) == ok.end())
		{
			sendResponse(fd, QUIT(message, reason));
			ok.push_back(fd);
		}
		it++;

	}
	return (ok);
}

void Server::broadcastTopic(std::string message, Channel *channel, std::string topic)
{

	std::set<int> clients = channel->getClients();
	std::set<int>::iterator itc = clients.begin();
	while (itc != clients.end())
	{
		int fd = *itc;
		sendResponse(fd, TOPIC(message, channel->getName(), topic));
		itc++;
	}
	return;
}
/* ===== FILE: srcs/Server.cpp ===== */

#include "Server.hpp"

/*CRASH WHEN WE CLOSE HEXCHAT. STILL WAITING FOR JOIN AND MORE COMMANDS*/

Server::Server() : _port(0), _servFd(-1), _serverName("ircserv") {}
bool Server::_sigFlag = false;//no signal received yet

void Server::sigHandler(int signum)
{
	(void)signum;
	std::cout << PURPLE << "Flag is true! " << signum << NC << std::endl;
	_sigFlag = true;
}
//we have to add this client to the list
void Server::checkNewClient(){
	sockaddr_in clientAddr;
	socklen_t	clientLen = sizeof(clientAddr);
	int clientFd = accept(_servFd, (sockaddr*)&clientAddr, &clientLen);
	if (clientFd == -1){
		if (errno == EAGAIN || errno == EWOULDBLOCK)
			return  ;
		std::cout << RED;
		std::perror("!Error: accept()");
		std::cout << NC;
		return ;
	}
	if (fcntl(_servFd, F_SETFL, O_NONBLOCK) == -1){
		::close(_servFd);
		throw std::runtime_error("!Error: fcntl(O_NONBLOCK)");
	}
	pollfd clientPollfd = {clientFd, POLLIN, 0};//new poll and its struct	
	Client newclient;
	newclient.setClientFd(clientFd);
	newclient.setClientIP(inet_ntoa(clientAddr.sin_addr));//this how we set the IP
	
	_pollFds.push_back(clientPollfd);
	_clients.push_back(newclient);
	
	std::cout << TURQUOISE << "<" << clientFd << "> Connected!" << NC << std::endl;
}

//this will give us the commands that are sending the clients
void Server::checkNewData(int fd){
	char buffer[1024];
	memset(buffer, 0, sizeof(buffer));//clears the buffer
	
	ssize_t bytes = recv(fd, buffer, sizeof(buffer) - 1, 0);
	if (bytes == 0)
	{
		std::cout << "flag_3\n";
		clearClient(fd);
		return ;
	}
	else if (bytes < 0) {
    	if (errno == EAGAIN || errno == EWOULDBLOCK)
			return;
	}
	Client *cli = getClient(fd);
	if (!cli)
		return ;
	cli->addBuffer(std::string(buffer, bytes));
	std::string &buff = cli->getBuff();
	size_t pos;
	
	//while((pos = buff.find("\n")) != std::string::npos){//just for MacOS test (yaja)
	while((pos = buff.find("\r\n")) != std::string::npos){
		std::string cmd = buff.substr(0, pos);
		buff.erase(0, pos + 2);
		if (!cmd.empty()){
			std::cout << YELLOW << "<" << fd << "> << " << NC << cmd << std::endl;
			parseCommand(cli, cmd);
		}
	}
}

void Server::createSocket()
{
	int opt = 1;
	struct sockaddr_in add; // used to store socket addresses for the Internet domain
	struct pollfd serverPollFd;

	// socket struct
	add.sin_family = AF_INET;		   // specify the IPv4 address protocol
	add.sin_addr.s_addr = INADDR_ANY;  // accept connections from any IP address
	add.sin_port = htons(this->_port); // convert port number to network byte order

	// create socket
	this->_servFd = socket(AF_INET, SOCK_STREAM, 0);
	if (this->_servFd < 0)
	{
		throw(std::runtime_error("Error creating socket"));
		close(_servFd);
	}
	// addresses reuse (to restart the server quickly)
	if (setsockopt(_servFd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1)
	{
		throw(std::runtime_error("Error setting reuse to socket"));
		close(_servFd);
	}
	// prevent to block incoming connections, to avoid to freeze the program with one client
	if (fcntl(_servFd, F_SETFL, O_NONBLOCK) == -1)
	{
		throw(std::runtime_error("Error setting non-block to socket"));
		close(_servFd);
	}
	// bind socket to an IP + port
	if (bind(_servFd, (struct sockaddr *)&add, sizeof(add)) < 0)
	{
		throw(std::runtime_error("Error binding socket"));
		close(_servFd);
	}
	if (listen(_servFd, 10) == -1)
	{
		throw(std::runtime_error("listen() crashed! :("));
		close(_servFd);
	}

	// poll is the one who monitors the socket
	serverPollFd.fd = _servFd;
	serverPollFd.events = POLLIN; // requested events
	serverPollFd.revents = 0;	  // returned events
	_pollFds.push_back(serverPollFd);
}

void Server::initServer(int port, std::string pwd)
{
	this->_port = port;
	this->_pwd = pwd;

	createSocket();

	std::cout << GREEN << "** IRC Server Created! **\n";
	std::cout << GREEN << "\tlistering on port: " << _port << NC << std::endl;

	while (Server::_sigFlag == false)
	{
		int activity = poll(_pollFds.data(), _pollFds.size(), -1);
		if (activity == -1)
			throw std::runtime_error("poll() crashed! :(");
		for (int i = _pollFds.size() - 1; i >= 0; --i)
		{
			if (!(_pollFds[i].revents & POLLIN))
				continue;
			if (_pollFds[i].fd == _servFd)
				checkNewClient();
			else
				checkNewData(_pollFds[i].fd);
		}
		// in order to avoid any further issue, we'll mark the clients for remove later
		for (int i = static_cast<int>(_clients.size()) - 1; i >= 0; --i)
		{
			if (_clients[i].isToRemove())
			{
				int fd = _clients[i].getClientFd();
				// look and delete from _pollFds
				for (size_t j = 0; j < _pollFds.size(); ++j)
				{
					if (_pollFds[j].fd == fd)
					{
						_pollFds.erase(_pollFds.begin() + j);
						break;
					}
				}
				// now let´s delete from channels
				for (size_t j = 0; j < _channels.size(); ){
					_channels[j].removeClient(fd);
					if (_channels[j].getClients().empty()){ //if is the only member, delete channel too
						_channels.erase(_channels.begin() + j);
						continue; //nothing to increment cause vector has delete a space
					}
					++j;
				}
				_clients.erase(_clients.begin() + i);
			}
		}
		// print clients and channels
	}
	close_fds(_pollFds);
}

void Server::parseCommand(Client *cli, const std::string &command)
{
	if (command.empty())
		return;
	// if it´s the 1st time, we need to verify his identity
	if (cli->getStatus() != AUTHENTICATED)
	{
		handShake(cli, command);
		return;
	}
	// handle other commands
	std::vector<std::string> tokens = Utils::split(command, ' ');
	if (tokens.empty())
		return;
	std::string cmd = tokens[0];
	for (size_t i = 0; i < cmd.size(); i++)
		cmd[i] = std::toupper(cmd[i]);

	switch (isCommand(cmd)){
		std::cout << ORANGE << "switch state commands" << std::endl;
		
		case PASS: passAuth(cli, tokens); break;
		case NICK: nickAuth(cli, tokens); break;
		case USER: break;//the user is only a register thing
		case JOIN: handleJoin(cli, tokens); break;
		//WHO
		case PRIVMSG: handlePrivmsg(cli, tokens); break;
		case PART: handlePart(cli, tokens); break;
		
		case UKNW: sendResponse(cli->getClientFd(), ERR_UNKNOWNCOMMAND(_serverName, cli->getNickname(), cmd)); break;
		case KICK: handleKick(cli, tokens); break;
		case MODE: handleMode(cli, tokens); break;
		case INVITE: handleInvite(cli, tokens); break;
		case QUIT: handleQuit(cli, tokens); break;
		case TOPIC: handleTopic(cli, tokens); break;
		case WHO: handleWho(cli, tokens); break;
		case PING: handlePing(cli, tokens); break;
		default:
			break;
	}
	/* switch (isCommand(cmd))
	{
		//case WHO: handleWho(cli, tokens); break;	//what exactly who do?

	default:
		break;
	} */
}

CommandType Server::isCommand(const std::string &cmd)
{

	std::cout << ORANGE << cmd << std::endl;
	if (cmd == "JOIN")
		return (JOIN);
	else if (cmd == "WHO")
		return (WHO);
	else if (cmd == "PRIVMSG")
		return (PRIVMSG);
	else if (cmd == "KICK")
		return (KICK);
	else if (cmd == "INVITE")
		return (INVITE);
	else if (cmd == "TOPIC")
		return (TOPIC);
	else if (cmd == "MODE")
		return (MODE);
	else if (cmd == "PASS")
		return (PASS);
	else if (cmd == "NICK")
		return (NICK);
	else if (cmd == "USER")
		return (USER);
	else if (cmd == "PART")
		return (PART);
	else if (cmd == "QUIT")
		return (QUIT);
	else if (cmd == "PING")
		return (PING);
	else
		return UKNW;
}
/* ===== FILE: srcs/ServerAuth.cpp ===== */

#include "Server.hpp"

//to authenticate the client

void Server::passAuth(Client *cli, const std::vector<std::string> &tokens)
{
	std::cout << "PASS AUTHENTIFICATION" << std::endl;
	std::string nick = cli->getNickname().empty() ? "*" : cli->getNickname();
	if (tokens.size() < 2){
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(nick, tokens[0]));
		return;
	}
//ANTES ERA ISLOGGED
	/* if (cli->isRegistered()){//este nos salta constantemente
		sendResponse(cli->getClientFd(), ERR_ALREADYREGISTERED(nick));
		return;
	} */
	std::string pass = tokens[1];
	if (tokens[1] != _pwd){
		sendResponse(cli->getClientFd(), ERR_PASSWDMISMATCH(nick));
		return;
	}
	else
		cli->setPass();
	/* if (cli->hasAll()){
		cli->setStatus(AUTHENTICATED);
		std::cout << YELLOW << "<" << cli->getClientFd() << "> " << "Authenticated"
			<< cli->getNickname() << NC << std::endl;
		sendResponse(cli->getClientFd(), RPL_WELCOME(nick, _serverName, cli->getClientIP()));
	} */
}

void Server::nickAuth(Client *cli, const std::vector<std::string> &tokens)
{
    std::cout << YELLOW << "1st status: " << NC << cli->getStatus();
	if (tokens.size() < 2){
		//we can improve this response:
		sendResponse(cli->getClientFd(), ERR_NONICKNAMEGIVEN());
		return;
	}
	std::string nick = tokens[1];
	if (!checkNick(nick)){
		//we can improve this response:
		sendResponse(cli->getClientFd(), ERR_ERRONEUSNICKNAME(nick));
		return;
	}
	if (nickTaken(nick)){
		sendResponse(cli->getClientFd(), ERR_NICKNAMEINUSE(nick));
		return;
	}
	//nick checked, we update client info and check log info
	if (!cli->hasNickname())
		cli->setFirstNick(nick);
	else{
		cli->setNewNick(nick);
		broadcastNewNick(cli);//sends a notification to channels
	}
	/* if (cli->hasAll()){
		cli->setStatus(AUTHENTICATED);
		std::cout << YELLOW << "<" << cli->getClientFd() << "> " << "Authenticated"
			<< cli->getNickname() << NC << std::endl;
		sendResponse(cli->getClientFd(), RPL_WELCOME(nick, _serverName, cli->getClientIP()));
	} */
}
void Server::userAuth(Client *cli, const std::vector<std::string> &tokens)
{
	std::string nick = cli->getNickname().empty() ? "*" : cli->getNickname();
	std::string real;
	if (tokens.size() < 5)
	{
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(nick, tokens[0]));
		return;
	}
	std::string user = tokens[1];
	if (tokens.size() > 5)
		real = appendToks(tokens, 4);
	else
		real = tokens[4];
	if (cli->hasUsername())
	{
		sendResponse(cli->getClientFd(), ERR_ALREADYREGISTERED(nick));
		return;
	}
	cli->setUser(user);
	cli->setRealName(real);
	/* if (cli->hasAll()){
		cli->setStatus(AUTHENTICATED);
		std::cout << YELLOW << "<" << cli->getClientFd() << "> " << "Authenticated: "
			<< cli->getNickname() << NC << std::endl;
		sendResponse(cli->getClientFd(), RPL_WELCOME(nick, _serverName, cli->getClientIP()));
	} */
}


void Server::handShake(Client *cli, const std::string &command){
	std::vector<std::string> tokens = Utils::split(command, ' ');
	if (tokens.empty())
		return;
	std::string cmd = tokens[0];
	for(size_t i = 0; i < cmd.size(); ++i)
		cmd[i] = std::toupper(cmd[i]);
	if (cmd == "CAP")
		std::cout << "IS LS\n";
	else if (cmd == "PASS")
		passAuth(cli, tokens);
	else if(cmd == "NICK")
		nickAuth(cli, tokens);
	else if (cmd == "USER")
		userAuth(cli, tokens);
/* 	else if (cmd == "JOIN"){
		std::cout << "handshake join\n";
		handleJoin(cli, tokens);
	} */
	else
	//check this error, because protocol has no params!!!!!
		sendResponse(cli->getClientFd(), ERR_NOTREGISTERED((cli->getNickname())));
	if (cli->hasAll()){
		cli->setStatus(AUTHENTICATED);
		std::cout << YELLOW << "<" << cli->getClientFd() << "> " << "Authenticated: "
			<< cli->getNickname() << NC << std::endl;
		sendResponse(cli->getClientFd(), RPL_WELCOME(cli->getNickname(), _serverName, cli->getClientIP()));
	}
}
/* ===== FILE: srcs/ServerAux.cpp ===== */

#include "Server.hpp"

Channel *Server::moveCreateChannel(const std::string &channelName){
	//if we have the name on the list, we send the channel
	for(size_t i = 0; i < _channels.size(); i++){
		if (_channels[i].getName() == channelName)
			return &_channels[i];
	}
	//if not, we add this new name on the vector
	_channels.push_back(Channel(channelName));
	return &_channels.back();
}

//We want the access just to that client
Client *Server::getClient(int fd){
	for (size_t i = 0; i < _clients.size(); ++i){
		if (_clients[i].getClientFd() == fd)
			return &_clients[i];
	}
	return NULL;
}

Client *Server::getClientByNick(const std::string &dest){
	for (size_t i = 0; i < _clients.size(); ++i){
		if (_clients[i].getNickname() == dest)
			return &_clients[i];
	}
	return NULL;
}

void Server::close_fds(std::vector<pollfd> &pollFds)
{
	int i = pollFds.size() - 1;
	
	while (i >= 0)
	{
		close(pollFds[i].fd);
		i--;
	}
	close(_servFd);
}

void Server::clearClient(int fd){
	Client *cli = getClient(fd);
	if (!cli)
		return ;
	cli->markForRevome();
	shutdown(fd, SHUT_RDWR);
	close(fd);
	std::cout << PURPLE << "<" << fd << "> Disconnected!" << NC << std::endl;
}




//DELETE LATEEER!!!!!!!!!!!
void Server::printChannels(const std::vector<Channel>& _channels){
    std::cout << "---- Lista de canales ----" << std::endl;
    for (size_t i = 0; i < _channels.size(); ++i){
        const Channel &ch =_channels[i];
        std::cout << "[" << i << "] Nombre: " << ch.getName();

        if (ch.hasTopic())
            std::cout << " | Topic: " << ch.getTopic();

        std::cout << "\n    Clientes (" << ch.getClients().size() << "): ";

        const std::set<int> &clients = ch.getClients();
        std::set<int>::const_iterator it = clients.begin();
        for (; it != clients.end(); ++it)
        {
            std::cout << *it;
            std::set<int>::const_iterator next = it;
            ++next;
            if (next != clients.end())
                std::cout << ", ";
        }
        std::cout << std::endl;
    }
    std::cout << "--------------------------" << std::endl;
}

// Muestra los clientes+fd autenticados y los conectados sin autenticar 
void Server::printClients(std::vector<Client>& _clients) {
    std::cout << "---- Lista de clientes ----" << std::endl;
    for (size_t i = 0; i < _clients.size(); ++i) {
		if (_clients[i].getStatus() == AUTHENTICATED){
        	std::cout << "Cliente " << i << " FD=" << _clients[i].getClientFd() 
			<< " " << _clients[i].getNickname() << std::endl;
    	} else {
			std::cout << "Cliente " << i << " FD=" << _clients[i].getClientFd() 
			<< " " << _clients[i].getNickname() << " NOT_AUTHENTICATED" << std::endl;
		}
	}
}
/* ===== FILE: srcs/ServerCommands.cpp ===== */

#include "Server.hpp"

//JOIN #channel_name ?mode (still have to check this part)
void Server::handleJoin(Client *cli, const std::vector<std::string> &tokens){
	std::cout << ORANGE << "Handel JOIN\n" << NC;
    //seguridad de registro?
	if (tokens.size() < 2){
        sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(cli->getNickname(), "JOIN"));
		return ;
	}
	std::string channelName = tokens[1];
	std::string key;
	
	if (channelName.empty() || channelName[0] != '#'){
		sendResponse(cli->getClientFd(), ERR_NOSUCHCHANNEL(channelName));
		return ;
	}
    if (tokens.size() >= 3){
			//chan->setKey(tokens[2]);
			key = tokens[2];
	}
	Channel *chan = moveCreateChannel(channelName);
	if (chan->isModeI() && !chan->isOperator(cli->getClientFd()) && !chan->isInvited(cli->getClientFd())){
		sendResponse(cli->getClientFd(), ERR_INVITEONLYCHAN(channelName));
		return;
	}
	if (chan->isModeK()){
		if (key.empty() || key != chan->getKey()){
			sendResponse(cli->getClientFd(), ERR_BADCHANNELKEY(cli->getNickname(), channelName));
			return;
		}
	}
	if (chan->isModeL() && chan->getClients().size() >= chan->getMaxUsers()){
	sendResponse(cli->getClientFd(), ERR_CHANNELISFULL(cli->getNickname(), channelName));
		return ;
	}
	//first user of the channel is the operator
	bool isFirst = chan->getClients().empty();
	chan->addClient(cli->getClientFd(), isFirst);
	chan->removeInvite(cli->getClientFd());
	cli->setChannel(chan);
    

	/*we need to announce of the JOIN to everyone*/
	//(:!@127.0.0.1 JOIN :#new) <--- this is how we can see the announce
	sendResponse(cli->getClientFd(), RPL_JOIN(cli->getNickname(), cli->getUsername(), cli->getClientIP(), channelName));

	//for loop to send the msg to every member of the channel
	const std::set<int> &members = chan->getClients();
	for (std::set<int>::const_iterator it = members.begin(); it != members.end(); ++it){
		if (*it != cli->getClientFd()){
			Client *currCli = getClient(*it);
			std::cout << ORANGE << "JOIN: sending msg to: " << cli->getNickname() << std::endl;
			if (currCli)
				//vvvvv check is we are getting the propper client FD 
				sendResponse(currCli->getClientFd(), RPL_JOIN(cli->getNickname(), cli->getUsername(), cli->getClientIP(), channelName));
		}
	}
    // Keep track of channels this client belongs to (needed for PART, QUIT, NICK broadcasts)
	std::string nickList;
	for(std::set<int>::const_iterator it = members.begin(); it != members.end(); ++it){
		Client *m = getClient(*it);
		if (!m)
            continue;//if this client does not exist
		if (chan->isOperator(*it))
            nickList += "@";
        nickList += m->getNickname() + " ";
	}
    if (!nickList.empty())
        nickList.erase(nickList.size() - 1);
    sendResponse(cli->getClientFd(), RPL_NAMREPLY(_serverName, cli->getNickname(), channelName, nickList));
    sendResponse(cli->getClientFd(), RPL_ENDOFNAMES(_serverName, cli->getNickname(), channelName));
}

//<PRIVMSG dest :message to send>
//<PRIVMSG {, dest} :message to send> (check if this is correct)
void Server::handlePrivmsg(Client *cli, const std::vector<std::string> &tokens){
	if (!cli)
		return ;
	std::string origin;

	if (cli->getNickname().empty())
		origin = "*";
	else
		cli->getNickname();
	//send a msg if we don't have all the params for this command
	if (tokens.size() < 3){
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(cli->getNickname(), tokens[0]));
		return ;
	}
	std::string msg = tokens[2];
	if (tokens[2][0] == ':'){
		msg= tokens[2].substr(1);
	}
	//loop for join again the tokens, but only since the msg begins
	for (size_t i = 3; i < tokens.size(); ++i)
		msg += " " + tokens[i];

	//split the targets of the msg (by commas)
	std::vector<std::string>targets = Utils::split(tokens[1], ',');
	for(size_t t = 0; t < targets.size(); ++t){
		std::string dest = targets[t];
		if (dest.empty())
			continue;
		//multiple dests
		if (dest[0] == '#'){
			Channel *chan = NULL;
			for (size_t i = 0; i < _channels.size(); ++i){
				if (_channels[i].getName() == dest){
					chan = &_channels[i];
					break ;
				}
			}
			//is chan does not exist:
			if (!chan){
				sendResponse(cli->getClientFd(), ERR_NOSUCHCHANNEL(cli->getNickname()));
				continue;
			}
			//if the client is not part of the channel:
			if (!chan->isMember(cli->getClientFd())){
				sendResponse(cli->getClientFd(), ERR_NOTONCHANNEL(cli->getNickname(), dest));
				continue;
			}
			const std::set<int>& users = chan->getClients();
			for(std::set<int>::const_iterator it = users.begin(); it != users.end(); ++it){
				if (*it != cli->getClientFd()){
					Client *other = getClient(*it);
					if (other)
						sendResponse(cli->getClientFd(), RPL_PRIVMSG(cli->getNickname(), dest, msg));
				}
			}			
		}
		//single dest
		else{
			Client *targetCli = getClientByNick(dest);
			if (!targetCli){
				sendResponse(cli->getClientFd(), ERR_NOSUCHNICK(cli->getNickname(), dest));
				continue;
			}
			else
				sendResponse(targetCli->getClientFd(), RPL_PRIVMSG(cli->getNickname(), dest, msg));
		}
	}
}

void Server::handlePart(Client *cli, const std::vector<std::string> &tokens){
	if (tokens.size() < 2 || !checkSyn(tokens[1]))
	{
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(cli->getNickname(), tokens[1]));
		return;
	}
	std::vector<std::string> channels = Utils::split(tokens[1], ',');
	std::string reason;
	if (tokens.size() > 2)
		reason = appendToks(tokens, 2);
	else
		reason = "";
	std::vector<std::string>::iterator it = channels.begin();
	while (it != channels.end()){
		if (channelExist((*it)) == true){
			Channel *chan = findChannel((*it));
			if (!chan->isMember(cli->getClientFd())){
				sendResponse(cli->getClientFd(), ERR_NOTONCHANNEL(cli->getNickname(), (*it)));
				it++;
				continue;
			}
			std::string message = cli->createMessage();
			sendResponse(cli->getClientFd(), RPL_PART(message, (*it), reason));
			broadcastPart((*it), message, reason);
			chan->removeClient(cli->getClientFd());
			if (chan->isEmpty())
				removeChannel((*it));
		}
		else
			sendResponse(cli->getClientFd(), ERR_NOSUCHCHANNEL(*it));
		it++;
	}
}

void Server::handleKick(Client *cli, std::vector<std::string> &tokens){
	int targetFd = 0;
	std::string reason;
	if (tokens.size() > 2)
		reason = appendToks(tokens, 3);
	else
		reason = "";
	if (!checkKick(tokens)){
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(cli->getNickname(), tokens[0]));
		return;
	}
	if (!channelExist(tokens[1])){
		sendResponse(cli->getClientFd(), ERR_NOSUCHCHANNEL(tokens[1]));
		return;
	}
	if (!emitorInChannel(cli->getClientFd(), tokens[1])){
		sendResponse(cli->getClientFd(), ERR_NOTONCHANNEL(cli->getNickname(), tokens[1]));
		return;
	}
	if (!emitorOperator(cli->getClientFd(), tokens[1])){
		sendResponse(cli->getClientFd(), ERR_CHANOPRIVSNEEDED(cli->getNickname(), tokens[1]));
		return;
	}
	if (!(targetFd = targetExist(tokens[2]))){
		sendResponse(cli->getClientFd(), ERR_NOSUCHNICK(cli->getNickname(), tokens[2]));
		return;
	}
	if (!targetInChannel(tokens[1], targetFd)){
		sendResponse(cli->getClientFd(), ERR_USERNOTINCHANNEL(cli->getNickname(), tokens[2], tokens[1]));
		return;
	}
	removeTarget(tokens[1], targetFd);
	std::string message = cli->createMessage();
	sendResponse(targetFd, KICK(message, tokens[1], tokens[2], reason));
	broadcastKick(tokens[1], message, tokens[2], reason);
}

void Server::handleMode(Client *cli, std::vector<std::string> &tokens){
	if (tokens.size() < 3){
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(cli->getNickname(), tokens[0]));
		return;
	}
	if (tokens[1][0] != '#'){
		sendResponse(cli->getClientFd(), ERR_UNKNOWNCOMMAND(_serverName, cli->getNickname(), tokens[0]));
		return;
	}
	if (!channelExist(tokens[1])){
		sendResponse(cli->getClientFd(), ERR_NOSUCHCHANNEL(tokens[1]));
		return;
	}
	Channel *channel = findChannel(tokens[1]);
	if (!emitorInChannel(cli->getClientFd(), tokens[1])){
		sendResponse(cli->getClientFd(), ERR_NOTONCHANNEL(cli->getNickname(), tokens[1]));
		return;
	}
	if (isChangeMode(tokens[2]) && validMode(tokens[2])){
		if (channel->isOperator(cli->getClientFd())){
				int success = 0;
			int targetFd = -1;
			std::string arg = "";

			if (tokens.size() > 3){
				arg = tokens[3];
				targetFd = findTarget(arg);
				if (targetFd == -1)
				{
					sendResponse(cli->getClientFd(), ERR_NOSUCHNICK(_serverName, tokens[3]));
					return;
				}
			}
			success = channel->manageModeChange(tokens[2], arg, targetFd);
			if (success == 1){
				sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(cli->getNickname(), tokens[0]));
				return;
			}
			else if (success == 2){
				sendResponse(cli->getClientFd(), ERR_USERNOTINCHANNEL(cli->getNickname(), tokens[3], channel->getName()));
				return;
			}
			else if (success == 3){
				sendResponse(cli->getClientFd(), ERR_INVALIDMODEPARAM(_serverName, cli->getNickname(), channel->getName(), "l", tokens[3]));
				return;
			}
			std::string message = cli->createMessage();
			message.append(appendToks(tokens, 0));
			broadcastMode(channel, message);
		}
		else{
			sendResponse(cli->getClientFd(), ERR_CHANOPRIVSNEEDED(cli->getNickname(), channel->getName()));
			return;
		}
	}
}

void Server::handleInvite(Client *cli, std::vector<std::string> &tokens){
	if (tokens.size() < 3){
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(cli->getNickname(), tokens[0]));
		return;
	}
	if (!channelExist(tokens[2])){
		sendResponse(cli->getClientFd(), ERR_NOSUCHCHANNEL(tokens[1]));
		return;
	}
	
	if (!emitorInChannel(cli->getClientFd(), tokens[2])){
		sendResponse(cli->getClientFd(), ERR_NOTONCHANNEL(cli->getNickname(), tokens[1]));
		return;
	}
	Channel *channel = findChannel(tokens[2]);
	if (!channel->isOperator(cli->getClientFd())){
		sendResponse(cli->getClientFd(), ERR_CHANOPRIVSNEEDED(cli->getNickname(), channel->getName()));
		return;
	}
	int targetFd = findTarget(tokens[1]);
	if (targetFd == -1){
		sendResponse(cli->getClientFd(), ERR_NOSUCHNICK(_serverName, tokens[2]));
		return;
	}
	if (channel->isMember(targetFd)){
		sendResponse(cli->getClientFd(), ERR_USERONCHANNEL(_serverName, cli->getNickname(), tokens[1], channel->getName()));
		return;
	}
	channel->inviteClient(targetFd);
	sendResponse(cli->getClientFd(), RPL_INVITING(_serverName, cli->getNickname(), tokens[1], channel->getName()));
	std::string message = cli->createMessage();
	sendResponse(targetFd, INVITE(message, tokens[1], channel->getName()));
}

void Server::handleQuit(Client *cli, std::vector<std::string> &tokens)
{
	std::string message = cli->createMessage();
	std::string reason;

	if (tokens.size() > 1)
		reason = appendToks(tokens, 1);
	else
		reason = "Client Quit";
	broadcastQuit(cli, message, reason);
	deleteClient(cli);
}

void Server::handleTopic(Client *cli, std::vector<std::string> &tokens)
{
	if (tokens.size() < 2)
	{
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(cli->getNickname(), tokens[0]));
		return;
	}
	if (!channelExist(tokens[1]))
	{
		sendResponse(cli->getClientFd(), ERR_NOSUCHCHANNEL(tokens[1]));
		return;
	}
	Channel *channel = findChannel(tokens[1]);
	if (!emitorInChannel(cli->getClientFd(), tokens[1]))
	{
		sendResponse(cli->getClientFd(), ERR_NOTONCHANNEL(cli->getNickname(), tokens[1]));
		return;
	}
	if (tokens.size() > 2)
	{
		if (channel->isModeT() && !channel->isOperator(cli->getClientFd()))
		{
			sendResponse(cli->getClientFd(), ERR_CHANOPRIVSNEEDED(cli->getNickname(), tokens[1]));
			return;
		}
		std::string topic = appendToks(tokens, 2);
		channel->setTopic(topic);
		std::string message = cli->createMessage();
		broadcastTopic(message, channel, topic);
	}
	else
	{
		if (channel->hasTopic())
			sendResponse(cli->getClientFd(), RPL_TOPIC(cli->getNickname(), channel->getName(), channel->getTopic()));
		else
			sendResponse(cli->getClientFd(), RPL_NOTOPIC(cli->getNickname(), channel->getName()));
	}
}


void Server::handleWho(Client *cli, std::vector<std::string> &tokens)
{
	if (tokens.size() < 2)
	{
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(cli->getNickname(), tokens[0]));
		return;
	}
	int type = whoType(tokens[1]);
	if (type == 1)
	{
		if (!channelExist(tokens[1]))
		{
			sendResponse(cli->getClientFd(), ERR_NOSUCHCHANNEL(tokens[1]));
			return;
		}
		Channel *channel = findChannel(tokens[1]);
		if (!channel->isMember(cli->getClientFd()))
		{
			sendResponse(cli->getClientFd(), ERR_NOSUCHCHANNEL(tokens[1]));
			return;
		}
		std::set<int> clients = channel->getClients();
		std::set<int>::iterator it = clients.begin();
		while (it != clients.end())
		{
			std::string message = buildWhoMessage((*it), channel->isOperator(*it));
			if (!message.empty())
			{
				sendResponse(cli->getClientFd(), RPL_WHOREPLY(cli->getNickname(), channel->getName(), message));
			}
			it++;
		}
		sendResponse(cli->getClientFd(), RPL_ENDOFWHO(cli->getNickname(), tokens[1]));
	}
	else if (type == 2)
	{
		int targetFd = findTarget(tokens[1]);
		if (targetFd < 0)
		{
			sendResponse(cli->getClientFd(),
				ERR_NOSUCHNICK(cli->getNickname(), tokens[1]));
			return;
		}
		std::vector<Channel>::iterator it = _channels.begin();
		while (it != _channels.end())
		{
			if (it->isMember(targetFd) && it->isMember(cli->getClientFd()))
			{
				std::string message = buildWhoMessage(targetFd, it->isOperator(targetFd));
				sendResponse(cli->getClientFd(), RPL_WHOREPLY(cli->getNickname(), it->getName(), message));
			}
			++it;
		}
		sendResponse(cli->getClientFd(), RPL_ENDOFWHO(cli->getNickname(), tokens[1]));
	}
}

void Server::handlePing(Client *cli, std::vector<std::string> &tokens)
{
	if (tokens.size() < 2)
		return;
	sendResponse(cli->getClientFd(), "PONG " + tokens[1]);
}
/* ===== FILE: srcs/Utils.cpp ===== */

#include "Server.hpp"

/* FORMATING RESPONSES*/
//this function will handle to convert all \n into \r\n, so everything will have the IRC format
std::string convertResponse(const std::string &response){
	std::string finalResponse;

	finalResponse.reserve(response.size() + 2);
	for (size_t i = 0; i < response.size(); i++){
		if (response[i] == '\n'){
			if (i == 0 || response[i - 1] !=  '\r')
				finalResponse += '\r';
		}
		finalResponse += response[i];
	}
	if (finalResponse.empty() || finalResponse[finalResponse.size() - 1] != '\n' \
	|| (finalResponse.size() > 1 && finalResponse[finalResponse.size() - 2] != '\r')){
		finalResponse += "\r\n";
	}
	return finalResponse;
}

void Server::sendResponse(int clientFd, const std::string &response){
	std::string formatResponse = convertResponse(response);

	if (send(clientFd, formatResponse.c_str(), formatResponse.size(), 0) == -1){
		std::cerr << RED << "Error sending response to: " << clientFd << " client." << NC << std::endl;
	}
}

/* parsing */
int Utils::check_port(char *port){
    int i = 0;
    long res = 0;

    while (port[i]){
        if (!isdigit(static_cast<unsigned char>(port[i])))
            throw std::runtime_error("Error: Invalid port: needs only digits.");
        res = res * 10 + (port[i] - '0');
        i++;
    }
    if (res <= 1023 || res > 65535){
        throw std::runtime_error("Error: Recommended port for IRC: 6667.");
    }
    return (static_cast<int>(res));
}

bool Utils::check_password(const std::string &password){
    if (password.empty() || password.size() > 25)
        return (false);
    for (size_t i = 0; i < password.size(); i++){
        if (password[i] < 33 || password[i] > 126)
            return false;
    }
    return true;
}

std::vector<std::string> Utils::split(const std::string &str, char delimiter){
	std::vector<std::string> tokens;
	std::stringstream ss(str);
	std::string token;

	while(std::getline(ss, token, delimiter)){
		if (!token.empty() && token[token.size() - 1] == '\r')
    		token.erase(token.size() - 1);
		tokens.push_back(token);
	}
	return tokens;
}

/*various checks*/
bool Server::checkNick(std::string nick){
	if (nick.empty())
		return (false);
	int i = 0;
	while (nick[i]){
		if (!isalnum(nick[i]) && nick[i] != '_')
			return (false);
		i++;
	}
	return (true);
}
bool Server::checkUser(std::string user) const{
	if (user.empty())
		return (false);
	int i = 0;
	while (user[i]){
		if (!isalnum(user[i]) && user[i] != '_'  && user[i] != '-' && user[i]!= '.')
			return (false);
		i++;
	}
	return (true);
}

bool Server::nickTaken(std::string nick) const{
	unsigned int i = 0;

	while (i < _clients.size()){
		if (_clients[i].getNick() == nick)
			return (true);
		i++;
	}
	return(false);
}

std::string Server::appendToks( const std::vector<std::string> &tokens, int start){

 	std::string res;
    unsigned int i = start;

    if (i >= tokens.size())
        return "";

    if (!tokens[i].empty() && tokens[i][0] == ':')
    {
        if (tokens[i].size() > 1)
            res = tokens[i].substr(1);
        i++;
    }

    while (i < tokens.size())
    {
        if (!res.empty())
            res += " ";
        res += tokens[i];
        i++;
    }

    return res;
}

bool Server::checkSyn(std::string channel){
	if (channel.empty())
		return (false);
	if (channel[0] != '#')
		return (false);
	return(true); 
}

bool Server::channelExist(std::string channel){
	std::vector<Channel>::iterator it = _channels.begin();
	while (it != _channels.end()){
		if ((*it).getName() == channel)
			return (true);
		it++;
	}
	return (false);
}

void Server::removeChannel(std::string chan){
	std::vector<Channel>::iterator it = _channels.begin();

	while (it != _channels.end()){
		if (chan == it->getName()){
			_channels.erase(it);
			return;
		}
		it++;
	}
}
bool Server::checkKick(std::vector<std::string> &tokens){
	if (tokens.size() < 3)
		return (false);
	if (tokens[1][0] != '#')
		return (false);
	return (true);
}

bool Server::emitorInChannel(int emitFd, std::string channel){
	std::vector<Channel>::iterator it = _channels.begin();

	while (it != _channels.end()){
		if ((*it).getName() == channel){
			if ((*it).isMember(emitFd))
				return (true);
		}
		it++;
	}
	return(false);
}

bool Server::emitorOperator(int fd, std::string channel){
	std::vector<Channel>::iterator it = _channels.begin();

	while (it != _channels.end()){
		if ((*it).getName() == channel){
			if ((*it).isOperator(fd))
				return (true);
		}
		it++;
	}
	return(false);
}

int Server::targetExist(std::string nick){
	std::vector<Client>::iterator it = _clients.begin();

	while (it != _clients.end()){
		if ((*it).getNickname() == nick)
			return ((*it).getClientFd());
		it++;
	}
	return(0);
}

bool Server::targetInChannel(std::string channel, int targetFd){
	std::vector<Channel>::iterator it = _channels.begin();

	while (it != _channels.end()){
		if ((*it).getName() == channel){
			if ((*it).isMember(targetFd))
				return (true);
		}
		it++;
	}
	return(false);
}

void Server::removeTarget(std::string channel, int targetFd){
	std::vector<Channel>::iterator it = _channels.begin();

	while (it != _channels.end()){
		if ((*it).getName() == channel)
			(*it).removeClient(targetFd);
		it++;
	}
	return;
}
Channel *Server::findChannel(std::string channel){
	std::vector<Channel>::iterator it = _channels.begin();

	while (it != _channels.end()){
		if ((*it).getName() == channel)
			return &(*it);
		it++;
	}
	return (NULL);
}
bool Server::isChangeMode(std::string mode){
	if (mode.size() == 2 && (mode[0] == '+' || mode[0] == '-'))
		return (true);
	return(false);
}

bool Server::validMode(std::string mode){
	if (mode.size() == 2 && (mode[1] == 'i' || mode[1] == 't' || 
		mode[1] == 'k' || mode[1] == 'o' || mode[1] == 'l'))
		return (true);
	if (mode.size() == 1 && (mode[0] == 'i' || mode[0] == 't' || 
	mode[0] == 'k' || mode[0] == 'o' || mode[0] == 'l'))
		return (true);
	return (false);
}

int Server::findTarget(std::string nick){
	std::vector<Client>::iterator it = _clients.begin();

	while (it != _clients.end()){
		if ((*it).getNickname() == nick)
			return ((*it).getClientFd());
		it++;
	}
	return (-1);
}

void Server::deleteClient(Client* cli)
{
    int fd = cli->getClientFd();
	std::vector<Channel>::iterator it = _channels.begin();

    while (it != _channels.end())
    {
        it->removeClient(fd);
        if (it->isEmpty())
            it = _channels.erase(it);
        else
            ++it;
    }
	std::vector<Client>::iterator itc = _clients.begin();
	while (itc != _clients.end())
	{
		if (itc->getClientFd() == fd)
		{
			_clients.erase(itc);
			break;
		}
		itc++;
	}	
    close(fd);
}

int Server::whoType(std::string cmd)
{
	if (cmd[0] == '#')
		return(1);
	return(2);
}

std::string Server::buildWhoMessage(int fd, bool op)
{
	std::vector<Client>::iterator it = _clients.begin();
	std::string message;

	while (it != _clients.end())
	{
		if ((*it).getClientFd() == fd)
		{
			message.append(" ");
			message.append((*it).getUsername());
			message.append(" ");
			message.append((*it).getClientIP());
			message.append(" ");
			message.append(_serverName);
			message.append(" ");
			message.append((*it).getNick());
			if (op)
				message.append(" @H");
			else
				message.append(" H");
			message.append(" 0 :");
			message.append((*it).getRealname());
			return (message);
		}
		it++;
	}
	return ("");
}

/* ===== FILE: main.cpp ===== */

//#include "Exception.hpp"
#include "Server.hpp"
#include "Utils.hpp"
//#include "Client.hpp"


int main(int argc, char** argv)
{
    std::string line;
	signal(SIGINT, Server::sigHandler);//^C. Interrupt the process
	signal(SIGQUIT, Server::sigHandler);//^\ Quit process (9/12/25->SEGV )
	
    if (argc != 3){
        std::cerr << ORANGE << "Usage: ./ircserv <port> <password>" << std::endl;
        return (1);
    }
	int port = 0;
	std::string password = argv[2];
    try
    {
        port = Utils::check_port(argv[1]);
		if (Utils::check_password(argv[2]) == false)
			throw std::runtime_error("Error: Invalid password.");
    }
    catch(const std::exception& e)
    {
        std::cerr << RED << e.what() << '\n';
        return (1);
    }
	 
    Server Server;
    try{
	    Server.initServer(port, password);
    }
    catch (const std::exception &ex){
		std::cout << "se viene error\n";
        //Server.close_fds() //ideal to close all files when get an exception
        std::cerr << RED << ex.what() << std::endl;
        return (1);
    }
	return (0);
}