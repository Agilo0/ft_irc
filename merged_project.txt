/* ========================================= */
/*      MERGED IRC SERVER SOURCE FILE        */
/* ========================================= */


/* ===== FILE: inc/Channel.hpp ===== */

#ifndef CHANNEL_HPP
#define CHANNEL_HPP

//#include "Server.hpp"
//#include "Utils.hpp"

enum CommandType{
	PASS,
	NICK,
	USER,
	PART,
	//CAPEND,
	JOIN,
	WHO,
	PRIVMSG,
	KICK,
	INVITE,
	TOPIC,
	MODE,
	UKNW
};


class Channel{
	private:
		std::string	_name;
		std::string _topic;
		std::string _key;//optional key to join the channel
		size_t		_maxUsers;
		bool		_iMode;//(-/= invite only)
		bool		_tMode;//(topic set by operators only)
		bool		_kMode;
		bool		_oMode;
		bool		_lMode;
		std::set<int> _clients;//all the clients that we have in the channel (store FDs)
		std::set<int> _operators;//operator is the one that has more privileges in the channel
		std::set<int> _invited;//clients that are invited to the channel
	
	public:
		Channel(const std::string &name);
		
		/*getters*/
		std::string getName() const;//get channel name
		std::string getTopic() const;
		std::string getKey() const;
		size_t		getMaxUsers() const;
		const std::set<int> &getClients() const;
		
		/*setters*/
		void setTopic(const std::string &topic);
		void setKey(const std::string &key);
		void setMaxUsers(int max);
		
		void setModeI(bool active);
		void setModeT(bool active);
		void setModeK(bool active);
		void setModeO(bool active);
		void setModeL(bool active);
		
		/*booleans*/
		bool hasTopic() const;
		bool isModeI() const;
		bool isModeT() const;
		bool isModeK() const;
		bool isModeO() const;
		bool isModeL() const;
		//bool hasKey() const;

		bool isEmpty() const;

		bool addClient(int fd, bool isOperator = false);
		bool isMember(int fd) const;
		bool isOperator(int fd) const;
		bool isInvited(int fd) const;

		//client management
		void removeClient(int fd);
		void addOperator(int fd);
		void removeOperator(int fd);
		void inviteClient(int fd);
		void removeInvite(int fd);

		//modes
		/* int manageModeChange(std::string mode, std::string arg, int targetFd);
		void manageK(bool sign, std::string arg);
		int manageO(bool sign, int targetFd);
		int manageL(bool sign, std::string arg);
		bool isStrictNumber(const std::string &s); */
		// void broadcastMode();

};


#endif
/* ===== FILE: inc/Client.hpp ===== */

#ifndef CLIENT_HPP
# define CLIENT_HPP

#include <string>
//#include "Server.hpp"
#include "Channel.hpp"

enum Status {
    NOT_AUTHENTICATED,
    PASS_OK,
    NICK_OK,
	NICK_AGAIN,
    USER_OK,
    AUTHENTICATED
};

class Client{
    private:
        int _clientFd;
        std::string _nickname;
		std::string _oldnick;
        std::string _username;
        std::string _realname;
		std::string _ip;//or host
		std::string _buffer;
        Status _status;
		bool hasNick, hasUser, hasPass, logged;
        bool _toRemove;
        std::vector<Channel*> _channels;

    public:
        Client();
        ~Client();
        
        //getters
        Status getStatus();
		int getClientFd() const;//<--socket FD of the client
        std::string getUsername() const;
		std::string getNickname() const;
		std::string getClientIP() const;
		std::string &getBuff();
        std::string getNick() const;
		std::string getOldnick() const;
		//Channel *getChannel(unsigned int index);
                
        //setters
        void setStatus(Status status);
        void setClientFd(int fd);
		void setClientIP(const std::string &newIP);
        void setPass();
		void setLog();
		void setFirstNick(std::string nick);
		void setNewNick(std::string nick);
		void setRealName(std::string name);
		void setUser(std::string name);
		void setChannel(Channel *channel);

        //bools
		bool isLogged() const;
		bool hasAll() const;
		bool hasPassw() const;
		bool hasNickname() const;
		bool hasUsername() const;
        bool isToRemove() const;

        //others
        void markForRevome();
        void addBuffer(const std::string &data);
		//int quitChannel(std::string channel);
		//std::string createMessage();

};

#endif

/* ===== FILE: inc/Responses.hpp ===== */

#ifndef RESPONSES_HPP
#define RESPONSES_HPP

#define ERR_UNKNOWNERROR(msg)(std::string (" (400) :") + msg)

// NICKNAME
#define ERR_ERRONEUSNICKNAME(nickname) (std::string("432 ") + nickname + " :Erroneous nickname")
#define ERR_NICKNAMEINUSE(nickname) (std::string("433 ") + nickname + " :Nickname is already in use")
#define ERR_NONICKNAMEGIVEN() (std::string("431 :No nickname given"))
#define ERR_NICKCOLLISION(nickname) (std::string("436 ") + nickname + " :Nickname collision KILL")
#define RPL_NICKCHANGE(oldnick, user, host, nick)(std::string(":") + oldnick + "!" + user + "@" + host + " NICK :" + nick)
#define RPL_NICKUSER(oldnick, newnick) (std::string (":" + oldnick + " NICK " + newnick))

// USER
#define ERR_NEEDMOREPARAMS(client, command) (std::string("461 ") + (client) + " " +(command) + " :Not enough parameters")
#define ERR_ALREADYREGISTRED() (std::string("462 :You may not reregister"))

// WELCOME
#define RPL_WELCOME(nickname, servername, hostname) \
    (std::string(":" + servername + " 001 " + nickname + \
    " :Welcome to the " + servername + " Network, " + nickname + "!" + hostname))
#define RPL_YOURHOST(servername, nickname) \
    (std::string(":" + servername + " 002 " + nickname + " Your host is " + servername + ", running version 1.0"))
#define RPL_CREATED(servername, time) \
    (std::string(":" + servername + " 003 This server was created " + time))
#define RPL_MYINFO(servername, nickname) \
    (std::string(":" + servername + " 004 " + nickname + " " + servername))


// JOIN
#define ERR_NOSUCHCHANNEL(channel) (std::string("403 ") + channel + " :No such channel")
#define ERR_CHANNELISFULL(nickname, channel) (std::string(":server_name 471 " + nickname + " " + channel + " :Cannot join channel (+l)"))
#define ERR_INVITEONLYCHAN(channel) (std::string("473 " + channel + " :Cannot join channel (+i)"))
#define ERR_BADCHANNELKEY(nickname, channel) (std::string("475 " + nickname + " " + channel + " :Cannot join channel (+k)"))
#define RPL_JOIN(nickname, username, hostname, channel) \
    (std::string(":" + nickname + "!" + username + "@" + hostname + " JOIN :" + channel))
#define RPL_NAMREPLY(servername, nickname, channel, clientlist) \
    (std::string(":" + servername + " 353 " + nickname + " = " + channel + " :" + clientlist))
#define RPL_ENDOFNAMES(nickname, channel) (std::string(":" + server.getServerName() + " 366 " + nickname + " " + channel + " :End of /NAMES list"))

// PRIVMSG
#define ERR_NORECIPIENT(servername) (std::string(":" + servername + " 411 :No recipient given (PRIVMSG)"))
#define ERR_NOTEXTTOSEND(servername) (std::string(":" + servername + " 412 :No text to send"))
#define ERR_CANNOTSENDTOCHAN(servername, channel) (std::string(":" + servername + " 404 " + channel + " :Cannot send to channel"))
#define ERR_NOSUCHNICK(servername, nickname) (std::string(":" + servername + " 401 " + nickname + " :No such nick/channel"))
#define RPL_PRIVMSG(sender, receiver, message) (std::string(":" + sender + " PRIVMSG " + receiver + " " + message))

// PASSWORD
#define ERR_PASSWDMISMATCH() (std::string("464 :Password incorrect"))


// PART
#define ERR_USERNOTINCHANNEL(servername, nickname, channel) (std::string(":" + servername + " 441 " + nickname + " " + channel + " :They aren't on that channel"))
#define ERR_NOTONCHANNEL(servername, channel) (std::string(":" + servername + " 442 " + channel + " :You're not on that channel"))

// MODE
#define RPL_CHANNELMODEIS(servername, nickname, channel, flag) \
    (std::string(":" + servername + " 324 " + nickname + " " + channel + " " + flag))
#define ERR_KEYSET(servername, channel) (std::string(":" + servername + " 467 " + channel + " :Channel key already set"))
#define ERR_UNKNOWNMODE(servername, user, flag) (std::string(":" + servername + " " + user + " 472 " + flag + " :is unknown mode char to me for "))
#define RPL_OPERATOR(client, username, hostname, channel, active, nick) (std::string (":" + client + "!" + username + "@" + hostname + " MODE " + active + "o " + channel + " " + nick))
// #define ERR_UMODEUNKNOWNFLAG(client)(std::string ("501: ") + client + " :Unknown MODE flag")

// :quien_invita!usuario@host INVITE tu_nick :#canal
// INVITE
#define ERR_USERONCHANNEL(servername, nickname, channel) \
    (std::string(":" + servername + " 443 " + nickname + " " + channel + " :is already on channel"))
#define ERR_CHANOPRIVSNEEDED(servername, channel) \
    (std::string(":" + servername + " 482 " + channel + " :You're not channel operator"))
#define RPL_INVITING(servername, nickname, channel, nicknameinvited) \
    (std::string(":" + servername + " 341 " + nickname + " " + channel + " " + nicknameinvited))
#define RPL_YOUVEBEENINVITED(client, username, hostname, invited, channel) \
    (std::string (":" + client + "!" + username + "@" + hostname + " INVITE " + invited + " " + channel))

// PING
#define RPL_PONG(servername, text) (std::string(":" + servername + " PONG " + text))

// QUIT
#define ERR_NORECIPIENTQUIT(servername) (std::string(":" + servername + " 431 :No recipient given (QUIT)"))
#define RPL_QUIT(nick, user, hostname, message)(std::string(":" + nick+ "!" + user + "@" + hostname + " QUIT :" + message))

// KICK
#define ERR_USERNOTINCHANNELKICK(servername, nickname, channel) (std::string(":" + servername + " 441 " + nickname + " " + channel + " :They aren't on that channel"))
#define RPL_KICKPART(client, username, hostname, channel, kickpart, nick, reason)(std::string (":" + client + "!" + username + "@" + hostname + kickpart + channel + " " + nick + reason))

// GENERAL
#define ERR_UNKNOWNCOMMAND(command) (std::string("421 " + command + " :Unknown command"))
#define ERR_NOTREGISTERED() (std::string("451 :You have not registered"))  // Error si mandamos algo sin estar registrados

// WHO
#define RPL_WHOREPLY(server, client, channel, username, hostname, nick, op, realname) \
    (std::string (":" + server + " 352 " + client + " " + channel + " " + username + " " + hostname + " " + server + " " + nick + " H" + op + " :0" + realname))
#define RPL_ENDOFWHO(server, client, channel) \
    (std::string (":" + server + " 315 " + client + " " + channel + " :End of /WHO list."))

// TOPIC
#define RPL_NOTOPIC(servername, channel) (std::string(":" + servername + " 331 " + channel + " :No topic is set"))
#define RPL_TOPIC(servername, client, channel, topic) (std::string(":" + servername + " 332 " + client + " " + channel + " " + topic))
#define RPL_CHANGETOPIC(client, user, host, channel, topic) (std::string (":" + client + "!" + user + "@" + host + " TOPIC " + channel + " " + topic))


#endif
/* ===== FILE: inc/Server.hpp ===== */

#ifndef SERVER_HPP
# define SERVER_HPP

#include "Utils.hpp"
#include "Client.hpp"
#include "Channel.hpp"
#include "Responses.hpp"

class Server{
    private:
		int _port;
		int _servFd;
		static bool _sigFlag;
		std::string _pwd;
		std::string _serverName;
		std::vector<struct pollfd> _pollFds;
		std::vector<Client> _clients;
		std::vector<Channel> _channels;

	//utils.cpp
		bool checkNick(std::string nick);
		bool checkUser(std::string user) const;
		bool nickTaken(std::string nick) const;
		std::string appendToks( const std::vector<std::string> &tokens, int start);

	//ServerAuth.cpp
		void passAuth(Client *cli, const std::vector<std::string> &tokens);
		void nickAuth(Client *cli, const std::vector<std::string> &tokens);
		void userAuth(Client *cli, const std::vector<std::string> &tokens);
		void handShake(Client *cli, const std::string &command);
	
	//Server.cpp
		void parseCommand(Client *cli, const std::string &command);
	
	//Client.cpp
		CommandType isCommand(const std::string &cmd);
		void sendResponse(int clientFd, const std::string &response);
	
	//ServerAux.cpp
		Channel* moveCreateChannel(const std::string &channelName);
		Client *getClient(int fd);
		//void broadcastNewNick(Client *cli);//works with channels
	
	//ServerCommands.cpp
		void handleJoin(Client *cli, const std::vector<std::string> &tokens);
		
    public:
		Server();
	//server.cpp
		void createSocket();
		void initServer(int port, std::string pwd);
	//ServerAux.cpp
		static void sigHandler(int signum);
		void checkNewClient();
		void checkNewData(int fd);
		void clearClient(int fd);
		void close_fds(std::vector<pollfd> &pollFds);

	
};

#endif

/* ===== FILE: inc/Utils.hpp ===== */

#ifndef UTILS_HPP
# define UTILS_HPP

#include "Server.hpp"

/*	/---------------\
   |	LIBRARIES 	 |
	\---------------/
*/
#include <iostream>
#include <string>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <csignal>
#include <sys/socket.h>
#include <netinet/in.h> //Internet address family
#include  <arpa/inet.h>
#include <fcntl.h>
#include <cerrno>
#include <unistd.h>
#include <poll.h>
#include <vector>
#include <iostream>
#include <set>
#include <sstream>
#include <algorithm>

/*	/---------------\
   |	COLORS	 	 |
	\---------------/
*/

#define NC "\033[0m"
#define RED "\e[1;91m"
#define GREEN "\e[1;92m"
#define YELLOW "\e[1;93m"
#define BLUE "\e[1;94m"
#define TURQUOISE "\e[1;38;5;80m"
#define FUCSIA "\e[1;38;5;201m"
#define PURPLE "\e[1;38;5;135m"
#define ORANGE "\e[1;38;2;255;128;0m"

//no utils class needed
class Utils{
	public:
		static std::vector<std::string>	split(const std::string &str, char delimiter);
        static int check_port(char *port);
		static bool check_password(const std::string &password);
         
};

//static std::vector<std::string>	split(const std::string &str, char delimiter);//is not defined yet 
//std::string convertResponse(const std::string &response);
#endif
/* ===== FILE: srcs/Channel.cpp ===== */

#include "Server.hpp"

Channel::Channel(const std::string &name) :
	_name(name),_topic(""),_key(""),
	_maxUsers(0), _iMode(false), _tMode(false),
	_kMode(false), _oMode(false), _lMode(false) {}

/*getters*/
std::string Channel::getName() const{ return _name; }
std::string Channel::getTopic() const{ return _topic; }
std::string Channel::getKey() const{ return _key; }
size_t Channel::getMaxUsers() const{ return _maxUsers; }
const std::set<int> &Channel::getClients() const{ return _clients; }

/*setters*/
void Channel::setTopic(const std::string &topic){ _topic = topic; }
void Channel::setKey(const std::string &key){
	_key = key;
	_kMode = true;
}
void Channel::setMaxUsers(int max){ _maxUsers = max; }

/*MODES*/
void Channel::setModeI(bool active){ _iMode = active;}
void Channel::setModeT(bool active){ _tMode = active;}
void Channel::setModeK(bool active){ _kMode = active;}
void Channel::setModeO(bool active){ _oMode = active;}
void Channel::setModeL(bool active){ _lMode = active;}

bool Channel::hasTopic() const {return !_topic.empty();}
bool Channel::isModeI() const {return _iMode; }//this has been previously changed by his set function
bool Channel::isModeT() const {return _tMode; }
bool Channel::isModeK() const {return _kMode; }
bool Channel::isModeO() const {return _oMode; }
bool Channel::isModeL() const {return _lMode; }

///						*WIP									*/
//NOT quite sure if we should use clean or create an specific function
// void Channel::removeClient(int fd){
// 	(void)fd;//but we should use the fd to know the exact client we are talking about
// 	_clients.clear();
// 	_operators.clear();
// }
void Channel::removeInvite(int fd){
	(void)fd;
	//remove the invitation
}
void Channel::removeOperator(int fd){
	(void)fd;
	//remove operator privileges
}


//we add the client to the operators list (if they are on the list)
void Channel::addOperator(int fd){
	if (_clients.count(fd))//it give us the match of the client
		_operators.insert(fd);
}
void Channel::inviteClient(int fd){ _invited.insert(fd); }

//new client has been add if we still have space left
bool Channel::addClient(int fd, bool isOperator){
	if (_lMode && _clients.size() >= _maxUsers)
		return false;
	_clients.insert(fd);
	if (isOperator)
		_operators.insert(fd);
	return true;
}
//if we found this fd on the list, means that is a member
bool Channel::isMember(int fd) const { return _clients.find(fd) != _clients.end(); }
bool Channel::isOperator(int fd) const { return _operators.find(fd) != _operators.end(); }
bool Channel::isInvited(int fd) const { return _clients.find(fd) != _clients.end(); }

void Channel::removeClient(int fd){
	_clients.erase(fd);
	_operators.erase(fd);
}

bool Channel::isEmpty() const {
	if (_clients.empty())
		return (true);
	return (false);
}



/* ===== FILE: srcs/Client.cpp ===== */

#include "Server.hpp"
//#include "Channel.hpp"

Client::Client(){
    hasNick = false;
	hasUser = false;
	hasPass = false;
	logged = false;
	_status = NOT_AUTHENTICATED;
    _toRemove = false;
}

Client::~Client() {}

//setters
void Client::setStatus(Status status){ _status = status; }
void Client::setClientFd(int fd){ _clientFd = fd; }
void Client::setClientIP(const std::string &newIP) { _ip = newIP; }
void Client::setPass() { hasPass = true; }
void Client::setFirstNick(std::string nick){
	_nickname = nick;
	hasNick = true;
}
void Client::setNewNick(std::string nick){
	_oldnick = _nickname;
	_nickname = nick;
}
void Client::setLog(){ logged = true; }
void Client::setUser(std::string name){
	_username = name;
	hasUser = true;
}
void Client::setRealName(std::string name) { _realname = name; }
void Client::setChannel(Channel *channel) { _channels.push_back(channel); }



//getters
Status Client::getStatus() { return _status; }
int Client::getClientFd() const { return _clientFd; }
std::string Client::getClientIP() const { return _ip; }
std::string Client::getUsername() const { return _username; }
std::string Client::getNickname() const { return _nickname;}
std::string &Client::getBuff() { return _buffer; }
std::string Client::getNick() const { return (_nickname); }
std::string Client::getOldnick() const{ return (_oldnick); }
/* Channel *Client::getChannel(unsigned int index){
	if (_channels.size() > index)
		return (_channels[index]);
	return (NULL);
} */


//bools
bool Client::isLogged() const{
	if (logged == true)
		return (true);
	return (false);
}
bool Client::hasAll() const{
	if (hasPass == true && hasNick == true && hasUser == true)
		return (true);
	return (false);
}
bool Client::hasNickname() const { return (hasNick);}
bool Client::hasUsername() const { return (hasUser); }
bool Client::hasPassw() const { return (hasPass); }
bool Client::isToRemove() const { return (_toRemove); }



//others
void Client::markForRevome() { _toRemove = true; }
void Client::addBuffer(const std::string &data){ _buffer += data; }
/* ===== FILE: srcs/Server.cpp ===== */

#include "Server.hpp"

/*CRASH WHEN WE CLOSE HEXCHAT. STILL WAITING FOR JOIN AND MORE COMMANDS*/

Server::Server() : _port(0), _servFd(-1), _serverName("ircserv") {}

void Server::createSocket()
{
	int opt = 1;
	struct sockaddr_in add; // used to store socket addresses for the Internet domain
	struct pollfd serverPollFd;

	// socket struct
	add.sin_family = AF_INET;		   // specify the IPv4 address protocol
	add.sin_addr.s_addr = INADDR_ANY;  // accept connections from any IP address
	add.sin_port = htons(this->_port); // convert port number to network byte order

	// create socket
	this->_servFd = socket(AF_INET, SOCK_STREAM, 0);
	if (this->_servFd < 0)
	{
		throw(std::runtime_error("Error creating socket"));
		close(_servFd);
	}
	// addresses reuse (to restart the server quickly)
	if (setsockopt(_servFd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1)
	{
		throw(std::runtime_error("Error setting reuse to socket"));
		close(_servFd);
	}
	// prevent to block incoming connections, to avoid to freeze the program with one client
	if (fcntl(_servFd, F_SETFL, O_NONBLOCK) == -1)
	{
		throw(std::runtime_error("Error setting non-block to socket"));
		close(_servFd);
	}
	// bind socket to an IP + port
	if (bind(_servFd, (struct sockaddr *)&add, sizeof(add)) < 0)
	{
		throw(std::runtime_error("Error binding socket"));
		close(_servFd);
	}
	if (listen(_servFd, 10) == -1)
	{
		throw(std::runtime_error("listen() crashed! :("));
		close(_servFd);
	}

	// poll is the one who monitors the socket
	serverPollFd.fd = _servFd;
	serverPollFd.events = POLLIN; // requested events
	serverPollFd.revents = 0;	  // returned events
	_pollFds.push_back(serverPollFd);
}

void Server::initServer(int port, std::string pwd)
{
	this->_port = port;
	this->_pwd = pwd;

	createSocket();

	std::cout << GREEN << "** IRC Server Created! **\n";
	std::cout << GREEN << "\tlistering on port: " << _port << NC << std::endl;

	while (Server::_sigFlag == false)
	{
		int activity = poll(_pollFds.data(), _pollFds.size(), -1);
		if (activity == -1)
			throw std::runtime_error("poll() crashed! :(");
		for (int i = _pollFds.size() - 1; i >= 0; --i)
		{
			if (!(_pollFds[i].revents & POLLIN))
				continue;
			if (_pollFds[i].fd == _servFd)
				checkNewClient();
			else
				checkNewData(_pollFds[i].fd);
		}
		// in order to avoid any further issue, we'll mark the clients for remove later
		for (int i = static_cast<int>(_clients.size()) - 1; i >= 0; --i)
		{
			if (_clients[i].isToRemove())
			{
				int fd = _clients[i].getClientFd();
				// look and delete from _pollFds
				for (size_t j = 0; j < _pollFds.size(); ++j)
				{
					if (_pollFds[j].fd == fd)
					{
						_pollFds.erase(_pollFds.begin() + j);
						break;
					}
				}
				// now let´s delete from channels
				/* for (size_t j = 0; j < _channels.size(); ){
					_channels[j].removeClient(fd);
					if (_channels[j].getClients().empty()){ //if is the only member, delete channel too
						_channels.erase(_channels.begin() + j);
						continue; //nothing to increment cause vector has delete a space
					}
					++j;
				} */
				_clients.erase(_clients.begin() + i);
			}
		}
		// print clients and channels
	}
	close_fds(_pollFds);
}

void Server::parseCommand(Client *cli, const std::string &command)
{
	if (command.empty())
		return;
	// if it´s the 1st time, we need to verify his identity
	if (cli->getStatus() != AUTHENTICATED)
	{
		std::cout << "AUTHENTICATING client\n" << NC;
		handShake(cli, command);
		return;
	}
	// handle other commands
	std::cout << ORANGE << "Handshake ok!!\n" << NC;
	std::vector<std::string> tokens = Utils::split(command, ' ');
	if (tokens.empty())
		return;
	std::string cmd = tokens[0];
	for (size_t i = 0; i < cmd.size(); i++)
		cmd[i] = std::toupper(cmd[i]);

	switch (isCommand(cmd)){
		std::cout << ORANGE << "switch commands" << std::endl;
		case JOIN: handleJoin(cli, tokens); break;//do we need a code for error handle???
		case UKNW: std::cerr << RED << "Unknown command for IRC \r\n" << NC << std::endl;
		default:
			break;
	}
	/* switch (isCommand(cmd))
	{
		case PRIVMSG: handlePrivmsg(cli, tokens); break;
		//case WHO: handleWho(cli, tokens); break;	//what exactly who do?
		case PASS: passAuth(cli, tokens); break;
		case NICK: nickAuth(cli, tokens); break;
		case USER: userAuth(cli, tokens); break;
		case PART: handlePart(cli, tokens); break;
		case KICK: handleKick(cli, tokens); break;
		case MODE: handleMode(cli, tokens); break;
		case INVITE: handleInvite(cli, tokens); break;
	default:
		break;
	} */
}

CommandType Server::isCommand(const std::string &cmd)
{

	std::cout << ORANGE << cmd << std::endl;
	if (cmd == "JOIN")
		return (JOIN);
	else if (cmd == "WHO")
		return (WHO);
	else if (cmd == "PRIVMSG")
		return (PRIVMSG);
	else if (cmd == "KICK")
		return (KICK);
	else if (cmd == "INVITE")
		return (INVITE);
	else if (cmd == "TOPIC")
		return (TOPIC);
	else if (cmd == "MODE")
		return (MODE);
	else if (cmd == "PASS")
		return (PASS);
	else if (cmd == "NICK")
		return (NICK);
	else if (cmd == "USER")
		return (USER);
	else if (cmd == "PART")
		return (PART);
	else
		return UKNW;
}
/* ===== FILE: srcs/ServerAuth.cpp ===== */

#include "Server.hpp"

//to authenticate the client

void Server::passAuth(Client *cli, const std::vector<std::string> &tokens)
{
	std::cout << "PASS AUTHENTIFICATION" << std::endl;
	std::string nick = cli->getNickname().empty() ? "*" : cli->getNickname();
	if (tokens.size() < 2){
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(nick, tokens[0]));
		return;
	}

	if (cli->isLogged()){//este nos salta constantemente
		sendResponse(cli->getClientFd(), ERR_ALREADYREGISTERED(nick));
		return;
	}
	std::string pass = tokens[1];
	if (tokens[1] != _pwd){
		sendResponse(cli->getClientFd(), ERR_PASSWDMISMATCH(nick));
		return;
	}
	else
		cli->setPass();
	if (cli->hasAll()){
		cli->setStatus(AUTHENTICATED);
		std::cout << YELLOW << "<" << cli->getClientFd() << "> " << "Authenticated"
			<< cli->getNickname() << NC << std::endl;
		sendResponse(cli->getClientFd(), RPL_WELCOME(nick, _serverName, cli->getClientIP()));
	}
}

void Server::nickAuth(Client *cli, const std::vector<std::string> &tokens)
{
    std::cout << YELLOW << "1st status: " << NC << cli->getStatus();
	if (tokens.size() < 2){
		sendResponse(cli->getClientFd(), ERR_NONICKNAMEGIVEN());
		return;
	}
	std::string nick = tokens[1];
	if (!checkNick(nick)){
		sendResponse(cli->getClientFd(), ERR_ERRONEUSNICKNAME(nick));
		return;
	}
	if (nickTaken(nick)){
		sendResponse(cli->getClientFd(), ERR_NICKNAMEINUSE(nick));
		return;
	}

	//nick checked, we update client info and check log info
	if (!cli->hasNickname())
		cli->setFirstNick(nick);
	//else{
	//	cli->setNewNick(nick);
	//	broadcastNewNick(cli);//sends a notification to channels
	//}
	if (cli->hasAll()){
		cli->setStatus(AUTHENTICATED);
		std::cout << YELLOW << "<" << cli->getClientFd() << "> " << "Authenticated"
			<< cli->getNickname() << NC << std::endl;
		sendResponse(cli->getClientFd(), RPL_WELCOME(nick, _serverName, cli->getClientIP()));
	}
}
void Server::userAuth(Client *cli, const std::vector<std::string> &tokens)
{
	std::string nick = cli->getNickname().empty() ? "*" : cli->getNickname();
	std::string user = tokens[1];
	std::string real;
	if (tokens.size() < 5)
	{
		sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(nick, tokens[0]));
		return;
	}
	if (tokens.size() > 5)
		real = appendToks(tokens, 4);
	else
		real = tokens[4];
	if (cli->hasUsername())
	{
		sendResponse(cli->getClientFd(), ERR_ALREADYREGISTERED(cli->getUsername()));
		return;
	}
	if (!cli->hasPassw())
	{
		sendResponse(cli->getClientFd(), ERR_NOTREGISTERED());
		return;
	}
	if (checkUser(user))
	{
		cli->setUser(user);
		cli->setRealName(real);
	}
	if (cli->hasAll()){
		cli->setStatus(AUTHENTICATED);
		std::cout << YELLOW << "<" << cli->getClientFd() << "> " << "Authenticated: "
			<< cli->getNickname() << NC << std::endl;
		sendResponse(cli->getClientFd(), RPL_WELCOME(nick, _serverName, cli->getClientIP()));
	}
}


void Server::handShake(Client *cli, const std::string &command){
	std::vector<std::string> tokens = Utils::split(command, ' ');
	if (tokens.empty())
		return;
	std::string cmd = tokens[0];
	for(size_t i = 0; i < cmd.size(); ++i)
		cmd[i] = std::toupper(cmd[i]);
	if (cmd == "PASS")
		passAuth(cli, tokens);
	else if(cmd == "NICK")
		nickAuth(cli, tokens);
	else if (cmd == "USER")
		userAuth(cli, tokens);
	else if (cmd == "JOIN" && cli->isLogged() == true){
		std::cout << "handshake join\n";
		handleJoin(cli, tokens);
	}
	else
		sendResponse(cli->getClientFd(), ERR_NOTREGISTERED());
}
/* ===== FILE: srcs/ServerAux.cpp ===== */

#include "Server.hpp"

bool Server::_sigFlag = false;//no signal received yet

void Server::sigHandler(int signum)
{
	(void)signum;
	std::cout << PURPLE << "Flag is true! " << signum << NC << std::endl;
	_sigFlag = true;
}

//we have to add this client to the list
void Server::checkNewClient(){
	sockaddr_in clientAddr;
	socklen_t	clientLen = sizeof(clientAddr);
	int clientFd = accept(_servFd, (sockaddr*)&clientAddr, &clientLen);
	if (clientFd == -1){
		if (errno == EAGAIN || errno == EWOULDBLOCK)
			return  ;
		std::cout << RED;
		std::perror("!Error: accept()");
		std::cout << NC;
		return ;
	}
	if (fcntl(_servFd, F_SETFL, O_NONBLOCK) == -1){
		::close(_servFd);
		throw std::runtime_error("!Error: fcntl(O_NONBLOCK)");
	}
	pollfd clientPollfd = {clientFd, POLLIN, 0};//new poll and its struct	
	Client newclient;
	newclient.setClientFd(clientFd);
	newclient.setClientIP(inet_ntoa(clientAddr.sin_addr));//this how we set the IP
	
	_pollFds.push_back(clientPollfd);
	_clients.push_back(newclient);
	
	std::cout << TURQUOISE << "<" << clientFd << "> Connected!" << NC << std::endl;
}

//this will give us the commands that are sending the clients
void Server::checkNewData(int fd){
	char buffer[1024];
	memset(buffer, 0, sizeof(buffer));//clears the buffer
	
	ssize_t bytes = recv(fd, buffer, sizeof(buffer) - 1, 0);
	if (bytes == 0)
	{
		std::cout << "flag_3\n";
		clearClient(fd);
		return ;
	}
	else if (bytes < 0) {
    	if (errno == EAGAIN || errno == EWOULDBLOCK)
			return;
	}
	Client *cli = getClient(fd);
	if (!cli)
		return ;
	cli->addBuffer(std::string(buffer, bytes));
	std::string &buff = cli->getBuff();
	size_t pos;
	
	//while((pos = buff.find("\r\n")) != std::string::npos){
	while((pos = buff.find("\n")) != std::string::npos){//just for MacOS test (yaja)
		std::cout << BLUE << "CheckNewData loop\n" << NC;
		
		std::string cmd = buff.substr(0, pos);
		buff.erase(0, pos + 2);
		if (!cmd.empty()){
			std::cout << YELLOW << "<" << fd << "> << " << cmd << NC << std::endl;
			parseCommand(cli, cmd);
		}
	}
}

Channel *Server::moveCreateChannel(const std::string &channelName){
	//if we have the name on the list, we send the channel
	for(size_t i = 0; i < _channels.size(); i++){
		if (_channels[i].getName() == channelName)
			return &_channels[i];
	}
	//if not, we add this new name on the vector
	_channels.push_back(Channel(channelName));
	return &_channels.back();
}

//We want the access just to that client
Client *Server::getClient(int fd){
	for (size_t i = 0; i < _clients.size(); ++i){
		if (_clients[i].getClientFd() == fd)
			return &_clients[i];
	}
	return NULL;
}

//Notification
/* void Server::broadcastNewNick(Client *cli)
{
	int i = 0;
	std::vector<int> clientFdsOk;
	std::vector<int> res;
	Channel *chan;

	while ((chan = cli->getChannel(i)) != NULL)
	{
		clientFdsOk = notifChannel(chan, cli->getOldnick(), cli->getNickname(), clientFdsOk);
		i++;
	}
} */

void Server::close_fds(std::vector<pollfd> &pollFds)
{
	int i = pollFds.size() - 1;
	
	while (i >= 0)
	{
		close(pollFds[i].fd);
		i--;
	}
	close(_servFd);
}

void Server::clearClient(int fd){
	Client *cli = getClient(fd);
	if (!cli)
		return ;
	cli->markForRevome();
	shutdown(fd, SHUT_RDWR);
	close(fd);
	std::cout << PURPLE << "<" << fd << "> Disconnected!" << NC << std::endl;
}
/* ===== FILE: srcs/ServerCommands.cpp ===== */

#include "Server.hpp"

void Server::handleJoin(Client *cli, const std::vector<std::string> &tokens){
	std::cout << ORANGE << "Handel JOIN\n" << NC;
	if (tokens.size() < 2){
        sendResponse(cli->getClientFd(), ERR_NEEDMOREPARAMS(cli->getNickname(), "JOIN"));
		return ;
	}
	std::string channelName = tokens[1];
	std::string key;
	Channel *chan = moveCreateChannel(channelName);
	
	if (tokens.size() >= 3){
			chan->setKey(tokens[2]);
			key = tokens[2];
	}
	if (channelName[0] != '#'){
		sendResponse(cli->getClientFd(), ERR_NOSUCHCHANNEL(channelName));
		return ;
	}
	if (chan->isModeI() && !chan->isOperator(cli->getClientFd()) && !chan->isInvited(cli->getClientFd())){
		sendResponse(cli->getClientFd(), ERR_INVITEONLYCHAN(channelName));
		return;
	}
	if (chan->isModeK()){
		if (key.empty() || key != chan->getKey()){
			sendResponse(cli->getClientFd(), ERR_BADCHANNELKEY(cli->getNickname(), channelName));
			return;
		}
	}
	if (chan->isModeL() && chan->getClients().size() >= chan->getMaxUsers()){
	sendResponse(cli->getClientFd(), ERR_CHANNELISFULL(/*cli->_nickname (key is tmp)*/key, channelName));
		return ;
	}
	//first user of the channel is the operator
	bool isFirst = chan->getClients().empty();
	chan->addClient(cli->getClientFd(), isFirst);
	chan->removeInvite(cli->getClientFd());//??

	/*we need to announce of the JOIN to everyone*/
	//(:!@127.0.0.1 JOIN :#new) <--- this is how we can see the announce
	sendResponse(cli->getClientFd(), RPL_JOIN(cli->getNickname(), cli->getUsername(), cli->getClientIP(), channelName));

	//for loop to send the msg to every member of the channel
	const std::set<int> &members = chan->getClients();
	for (std::set<int>::const_iterator it = members.begin(); it != members.end(); ++it){
		if (*it != cli->getClientFd()){
			Client *currCli = getClient(*it);
			std::cout << ORANGE << "JOIN: sending msg to: " << cli->getNickname() << std::endl;
			if (currCli)
				//vvvvv check is we are getting the propper client FD 
				sendResponse(currCli->getClientFd(), RPL_JOIN(cli->getNickname(), cli->getUsername(), cli->getClientIP(), channelName));
		}
	}
	cli->setChannel(chan); //???
	std::cout << RED << "Finish sending notification to clients" << std::endl;
	//HERE WE NEED THE 1ST NICKS LIST!! (CHECK WHY)
	//std::ostringstream nicks;
	/* for(std::set<int>::const_iterator it = members.begin(); it != members.end(); ++it){
		Client *m = getClient(*it);
		if (!m) continue;//if this client does not exist
		if (chan->isOperator(*it))//this int is operator	
			
	} */
}

/* ===== FILE: srcs/Utils.cpp ===== */

#include "Server.hpp"

/* FORMATING RESPONSES*/
//this function will handle to convert all \n into \r\n, so everything will have the IRC format
std::string convertResponse(const std::string &response){
	std::string finalResponse;

	finalResponse.reserve(response.size() + 2);
	for (size_t i = 0; i < response.size(); i++){
		if (response[i] == '\n'){
			if (i == 0 || response[i - 1] !=  '\r')
				finalResponse += '\r';
		}
		finalResponse += response[i];
	}
	if (finalResponse.empty() || finalResponse[finalResponse.size() - 1] != '\n' \
	|| (finalResponse.size() > 1 && finalResponse[finalResponse.size() - 2] != '\r')){
		finalResponse += "\r\n";
	}
	return finalResponse;
}

void Server::sendResponse(int clientFd, const std::string &response){
	std::string formatResponse = convertResponse(response);

	if (send(clientFd, formatResponse.c_str(), formatResponse.size(), 0) == -1){
		std::cerr << RED << "Error sending response to: " << clientFd << " client." << NC << std::endl;
	}
}

/* parsing */
int Utils::check_port(char *port){
    int i = 0;
    long res = 0;

    while (port[i])
    {
        if (!isdigit(static_cast<unsigned char>(port[i])))
            throw std::runtime_error("Error: Invalid port: needs only digits.");
        res = res * 10 + (port[i] - '0');
        i++;
    }
    if (res <= 1023 || res > 65535){
        throw std::runtime_error("Error: Recommended port for IRC: 6667.");
    }
    return (static_cast<int>(res));
}

bool Utils::check_password(const std::string &password){
    if (password.empty() || password.size() > 25)
        return (false);
    for (size_t i = 0; i < password.size(); i++){
        if (password[i] < 33 || password[i] > 126)
            return false;
    }
    return true;
}


//split all the tokens for proper parsing
std::vector<std::string> Utils::split(const std::string &str, char delimiter){
	std::vector<std::string> tokens;
	std::stringstream ss(str);
	std::string token;

	while(std::getline(ss, token, delimiter))
	{
		if (!token.empty() && token[token.size() - 1] == '\r')
    		token.erase(token.size() - 1);
		tokens.push_back(token);
	}
	return tokens;
}


/*various checks*/

bool Server::checkNick(std::string nick)
{
	if (nick.empty())
		return (false);
	int i = 0;
	while (nick[i])
	{
		if (!isalnum(nick[i]) && nick[i] != '_')
			return (false);
		i++;
	}
	return (true);
}
bool Server::checkUser(std::string user) const
{
	if (user.empty())
		return (false);
	int i = 0;
	while (user[i])
	{
		if (!isalnum(user[i]) && user[i] != '_'  && user[i] != '-' && user[i]!= '.')
			return (false);
		i++;
	}
	return (true);
}

bool Server::nickTaken(std::string nick) const
{
	unsigned int i = 0;

	while (i < _clients.size())
	{
		if (_clients[i].getNick() == nick)
		{
			return (true);
		}

		i++;
	}
	return(false);
}


std::string Server::appendToks( const std::vector<std::string> &tokens, int start)
{
	std::string res;

	unsigned int i = start;
	while (i < tokens.size())
	{
		res +=  tokens[i];
		res += ' ';
		i++;
	}
	return (res);
}
/* ===== FILE: main.cpp ===== */

//#include "Exception.hpp"
#include "Server.hpp"
#include "Utils.hpp"
//#include "Client.hpp"


int main(int argc, char** argv)
{
    std::string line;
	signal(SIGINT, Server::sigHandler);//^C. Interrupt the process
	signal(SIGQUIT, Server::sigHandler);//^\ Quit process (9/12/25->SEGV )
	
    if (argc != 3){
        std::cerr << ORANGE << "Usage: ./ircserv <port> <password>" << std::endl;
        return (1);
    }
	int port = 0;
	std::string password = argv[2];
    try
    {
        port = Utils::check_port(argv[1]);
		if (Utils::check_password(argv[2]) == false)
			throw std::runtime_error("Error: Invalid password.");
    }
    catch(const std::exception& e)
    {
        std::cerr << RED << e.what() << '\n';
        return (1);
    }
	 
    Server Server;
    try{
	    Server.initServer(port, password);
    }
    catch (const std::exception &ex){
		std::cout << "se viene error\n";
        //Server.close_fds() //ideal to close all files when get an exception
        std::cerr << RED << ex.what() << std::endl;
        return (1);
    }
	return (0);
}
